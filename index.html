<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CYBORG CLUB 2777 - RHYTHM DUNGEON CRAWLER</title>
    <style>
        :root {
            --bg-color: #050505;
            --player-color: #00ffff;      /* CIAN para jugador */
            --interact-color: #ff00ff;    /* MAGENTA para interacciones */
            --excellent: #00ffff;
            --great: #adff2f;
            --good: #ffd700;
            --miss: #ff4500;
            --playlist-color: #ff00ff;
            --powerup-color: #ffff00;
            --panel-bg: rgba(10, 10, 10, 0.98);
            --border-color: #333;
            --terminal-font: 'Courier New', Courier, monospace;
            --npc-inactive: #666666;      /* NPCs apagados */
            --npc-active: #ff00ff;        /* NPCs encendidos (magenta) */
        }

        body {
            background-color: var(--bg-color);
            color: #eee;
            font-family: var(--terminal-font);
            display: flex;
            margin: 0;
            height: 100vh;
            overflow: hidden;
            text-transform: uppercase;
        }

        #main-view {
            flex-grow: 1; 
            display: flex; 
            flex-direction: column;
            align-items: center; 
            justify-content: center; 
            position: relative;
            padding: 20px;
            box-sizing: border-box;
            min-height: 100vh;
        }

        /* PANELES LATERALES */
        .side-panel {
            position: fixed; top: 0; width: 300px; max-width: 90vw; height: 100vh;
            background: var(--panel-bg); border: 1px solid var(--border-color);
            padding: 20px; display: none; flex-direction: column;
            gap: 8px; overflow-y: auto; z-index: 2000; backdrop-filter: blur(8px);
            box-sizing: border-box;
        }
        #debug-panel { right: 0; border-left: 1px solid var(--player-color); }
        #appearance-panel { left: 0; border-right: 1px solid var(--excellent); }
        #playlist-panel { 
            left: 50%; 
            transform: translateX(-50%); 
            border: 1px solid var(--playlist-color); 
            height: auto; 
            max-height: 80vh;
            top: 60px; 
            border-radius: 5px; 
        }
        #powerup-panel { 
            left: 50%; 
            transform: translateX(-50%); 
            border: 1px solid var(--powerup-color); 
            height: auto; 
            max-height: 80vh;
            top: 60px; 
            border-radius: 5px; 
        }

        .debug-group { 
            display: flex; flex-direction: column; gap: 4px; 
            background: #000; padding: 8px; border: 1px solid #222;
        }
        .debug-group label { font-size: 9px; letter-spacing: 1px; color: #888; display: flex; justify-content: space-between; align-items: center; }

        h3 { font-size: 11px; margin: 5px 0; letter-spacing: 2px; border-bottom: 1px solid #333; padding-bottom: 5px; color: #fff; }

        /* UI */
        #ui-layer { 
            text-align: center; 
            margin-bottom: 10px; 
            min-width: 450px; 
            position: relative; 
            z-index: 50; 
            margin-top: 20px;
        }
        #combo-counter { 
            font-size: 42px; 
            color: var(--interact-color);  /* MAGENTA para combo */
            font-weight: 900; 
            margin: 0; 
            text-shadow: 0 0 10px var(--interact-color); 
            line-height: 1;
        }
        #accuracy-feedback { 
            font-size: 12px; 
            letter-spacing: 4px; 
            height: 20px; 
            margin-top: 5px; 
            font-weight: bold; 
            min-height: 20px;
        }
        
        #status-hud { 
            font-size: 11px; color: var(--powerup-color); background: rgba(0, 0, 0, 0.9); 
            padding: 10px; border: 1px solid var(--powerup-color); margin-top: 10px; 
            display: none; flex-direction: column; align-items: center; gap: 5px;
            width: 450px;
            margin-left: auto;
            margin-right: auto;
        }
        .progress-bar-container { width: 100%; height: 4px; background: #333; position: relative; }
        #progress-fill { height: 100%; background: var(--powerup-color); width: 100%; transition: width 0.1s linear; }

        /* JUEGO */
        #bpm-display { 
            position: fixed; 
            top: 20px; 
            right: 20px; 
            font-size: 20px; 
            color: var(--playlist-color); 
            border: 1px solid var(--playlist-color); 
            padding: 5px 12px; 
            background: rgba(0,0,0,0.9); 
            z-index: 100; 
            min-width: 100px;
            text-align: center;
        }
        #volume-control { 
            position: fixed; 
            top: 70px; 
            left: 20px; 
            display: flex; 
            flex-direction: column; 
            align-items: flex-start;
            gap: 4px; 
            background: rgba(0,0,0,0.9); 
            padding: 8px 10px; 
            border: 1px solid #333; 
            z-index: 100; 
            min-width: 140px;
            max-width: 180px;
        }
        #volume-control label {
            font-size: 8px;
            white-space: nowrap;
            margin: 0;
            width: 100%;
        }
        #volume-control input[type="range"] {
            width: 100%;
            height: 4px;
            margin: 0;
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            outline: none;
        }
        #volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--player-color);  /* CIAN para controles */
            cursor: pointer;
            border-radius: 50%;
        }
        #volume-control input[type="range"]::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: var(--player-color);
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        #game-container { 
            width: 450px; 
            border: 1px solid #333; 
            background: #000; 
            position: relative; 
            transition: transform 0.05s ease-out;
            filter: none; /* Para efectos glitch din√°micos */
        }
        #zona-juego { display: block; width: 450px; height: 350px; }
        #zona-beat { 
            width: 450px; 
            height: 100px; 
            background: linear-gradient(to bottom, #0a0a0a, #000); 
            border-top: 2px solid #222; 
            position: relative; 
            overflow: hidden; 
        }
        #beat-target { position: absolute; left: 30px; top: 50%; transform: translateY(-50%); width: 40px; height: 40px; border: 2px solid #444; }
        .note { 
            position: absolute; 
            top: 50%; 
            transform: translateY(-50%); 
            width: 30px; 
            height: 30px; 
            border-radius: 6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-weight: bold; 
            font-size: 16px; 
            z-index: 5; 
            transition: transform 0.1s ease;
            will-change: transform, left;
        }
        
        /* DDR - EFECTO AL GOLPEAR NOTA */
        .note.hit {
            transform: translateY(-50%) scale(1.4);
            opacity: 0.8;
            filter: brightness(1.5);
        }
        
        .inverted { filter: invert(1) hue-rotate(180deg); }
        
        /* GLITCH EFFECTS */
        .glitch-low { filter: contrast(1.2) hue-rotate(10deg) saturate(1.3); }
        .glitch-critical { 
            filter: contrast(1.5) hue-rotate(45deg) saturate(2) brightness(1.1);
            animation: glitchPulse 0.3s infinite alternate;
        }
        
        @keyframes glitchPulse {
            0% { filter: contrast(1.5) hue-rotate(45deg) saturate(2) brightness(1.1); }
            100% { filter: contrast(1.8) hue-rotate(90deg) saturate(2.5) brightness(1.3); }
        }

        /* BOTONES Y INPUTS */
        .btn { padding: 8px; font-weight: bold; cursor: pointer; border: 1px solid #444; background: #111; color: #eee; font-family: var(--terminal-font); font-size: 10px; }
        .btn:hover { background: #222; border-color: #888; }
        .menu-toggle { 
            position: fixed; 
            top: 20px; 
            background: rgba(0,0,0,0.9); 
            border: 1px solid #333; 
            color: #777; 
            z-index: 1500; 
            white-space: nowrap;
        }
        input[type="range"], select { background: #000; color: #fff; border: 1px solid #333; }
        
        /* Menu button positioning to avoid overlaps */
        #open-appearance { left: 20px; }
        #open-playlist { left: 180px; }
        #open-powerups { right: 180px; }
        #open-debug { right: 20px; }

        /* OVERLAY INICIAL */
        #start-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.96); z-index: 3000;
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 15px;
            backdrop-filter: blur(10px); padding: 20px;
        }
        #pre-game-pu-list {
            display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 620px;
            background: #111; padding: 20px; border: 1px solid #444;
        }
        
        /* ============================================ */
        /* CONTROLES M√ìVILES Y PANTALLA COMPLETA */
        /* ============================================ */
        
        /* BOT√ìN TOGGLE M√ìVIL */
        #mobile-toggle-btn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--player-color);  /* CIAN */
            border-radius: 8px;
            color: var(--player-color);
            font-family: var(--terminal-font);
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1001;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
            white-space: nowrap;
            display: none;
        }
        
        #mobile-toggle-btn.active {
            background: var(--player-color);
            color: #000;
        }
        
        /* PANEL T√ÅCTIL M√ìVIL */
        #touch-controls-panel {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 200px;
            z-index: 1000;
            touch-action: none;
        }
        
        /* BOTONES T√ÅCTILES */
        .touch-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid var(--player-color);  /* CIAN */
            border-radius: 50%;
            color: var(--player-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            user-select: none;
            touch-action: none;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            transition: all 0.1s;
        }
        
        .touch-btn:active {
            background: var(--player-color);
            color: #000;
            transform: scale(0.9);
        }
        
        /* POSICIONES DE LOS BOTONES T√ÅCTILES (CRUZ) */
        .touch-up { top: 0; left: 115px; }
        .touch-down { bottom: 0; left: 115px; }
        .touch-left { top: 65px; left: 40px; }
        .touch-right { top: 65px; right: 40px; }
        
        /* BOT√ìN DE ACCI√ìN T√ÅCTIL */
        #touch-action-btn {
            position: absolute;
            right: 20px;
            bottom: 20px;
            width: 80px;
            height: 80px;
            background: rgba(255, 0, 255, 0.8);
            border: 3px solid var(--interact-color);  /* MAGENTA */
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            z-index: 1001;
            cursor: pointer;
            display: none;
        }
        
        /* NUEVO HUD COMPACTO PARA CYBORG CLUB 2777 */
        #cyborg-hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
            z-index: 100;
            background: rgba(0,0,0,0.9);
            padding: 6px 12px;
            border: 1px solid var(--player-color);
            border-radius: 4px;
            min-width: 160px;
            transition: opacity 0.3s ease;
        }
        
        #hud-toggle-btn {
            position: absolute;
            top: -10px;
            right: -10px;
            width: 20px;
            height: 20px;
            background: #000;
            border: 1px solid var(--player-color);
            border-radius: 50%;
            color: var(--player-color);
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 101;
        }
        
        #hud-toggle-btn:hover {
            background: var(--player-color);
            color: #000;
        }
        
        #hydration-bar-container {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin: 2px 0;
        }
        
        #hydration-fill {
            height: 100%;
            background: var(--player-color);
            width: 100%;
            transition: width 0.3s ease;
        }
        
        #hydration-percentage {
            font-size: 9px;
            color: var(--player-color);
            margin-left: 4px;
        }
        
        #hud-bottom-row {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 9px;
        }
        
        #impurity-counter {
            color: #ff4444;
        }
        
        #style-rating {
            color: var(--interact-color);
            font-weight: bold;
        }
        
        /* ESCALADO PARA M√ìVILES */
        @media (max-width: 768px) {
            body {
                justify-content: center;
                align-items: flex-start;
                padding-top: 10px;
                overflow-x: hidden;
            }
            
            #main-view {
                transform-origin: top center;
                transform: scale(0.85);
                margin-top: 20px;
            }
            
            #mobile-toggle-btn {
                display: block;
            }
            
            .menu-toggle {
                font-size: 9px;
                padding: 6px 8px;
            }
            
            #open-appearance { left: 10px; }
            #open-playlist { left: 110px; }
            #open-powerups { right: 110px; }
            #open-debug { right: 10px; }
            
            #bpm-display {
                font-size: 14px;
                padding: 4px 8px;
                top: 60px;
                right: 10px;
            }
            
            #volume-control {
                top: 60px;
                left: 10px;
                padding: 6px 8px;
                max-width: 140px;
            }
            
            #cyborg-hud {
                top: 100px;
                left: 50%;
                transform: translateX(-50%) scale(0.9);
                padding: 5px 10px;
                min-width: 140px;
            }
        }
        
        @media (max-width: 480px) {
            #main-view {
                transform: scale(0.75);
            }
            
            .menu-toggle {
                font-size: 8px;
                padding: 5px 6px;
            }
            
            #touch-controls-panel {
                width: 280px;
                height: 180px;
            }
            
            .touch-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
        }
        
        /* ESTILOS PARA PANTALLA COMPLETA */
        :fullscreen #main-view {
            transform: scale(1);
        }
        
        :-webkit-full-screen #main-view {
            transform: scale(1);
        }
        
        :-moz-full-screen #main-view {
            transform: scale(1);
        }
    </style>
</head>
<body>

    <div id="bpm-display">BPM: 120</div>
    
    <!-- NUEVO HUD COMPACTO PARA CYBORG CLUB 2777 -->
    <div id="cyborg-hud">
        <button id="hud-toggle-btn">‚ñº</button>
        <div style="font-size: 9px; color: var(--player-color);">CYBORG CLUB 2777</div>
        <div style="display: flex; align-items: center; width: 100%;">
            <div id="hydration-bar-container">
                <div id="hydration-fill"></div>
            </div>
            <div id="hydration-percentage">100%</div>
        </div>
        <div id="hud-bottom-row">
            <div id="impurity-counter">IMP: <span id="impurity-value">0</span></div>
            <div id="style-rating">S</div>
        </div>
    </div>

    <div id="volume-control">
        <label style="color:var(--player-color)">MASTER</label>
        <input type="range" id="input-volume" min="-60" max="0" value="-10">
        <label style="color:#00ffff; margin-top:4px;">KICK</label>
        <input type="range" id="input-kick-volume" min="-60" max="0" value="0" step="1">
        <label style="color:#ff00ff; margin-top:4px;">SNARE</label>
        <input type="range" id="input-snare-volume" min="-60" max="0" value="-50" step="1">
    </div>

    <button id="open-appearance" class="btn menu-toggle">[ DISE√ëO_CYBORG ]</button>
    <button id="open-playlist" class="btn menu-toggle">[ PLAYLIST_PRO ]</button>
    <button id="open-powerups" class="btn menu-toggle" style="border-color: var(--powerup-color);">[ CHEMICALS ]</button>
    <button id="open-debug" class="btn menu-toggle">[ SISTEMA_CORE ]</button>
    
    <!-- BOT√ìN TOGGLE M√ìVIL -->
    <button id="mobile-toggle-btn">üì± MODO CIBORG</button>

    <div id="appearance-panel" class="side-panel">
    <button id="close-appearance" class="btn">_CERRAR_</button>
    
    <h3 style="color:var(--player-color)">VISUAL_CONFIG_CYBORG</h3>
    <div class="debug-group"><label>CLUB_SIZE</label><input type="range" id="input-grid" min="16" max="64" step="2" value="32"></div>
    <div class="debug-group"><label>CYBORG_AVATAR</label>
        <select id="user-avatar">
            <option value="(‚åê‚ñ†_‚ñ†)">COOL</option>
            <option value="(^o^)">HYPE</option>
            <option value="(‚óï‚Äø‚óï)">KAWAII</option>
            <option value="d(-_-)b">DJ_SET</option>
        </select>
    </div>
    <div class="debug-group"><label>RHYTHM_HINTS</label><input type="checkbox" id="check-hints" checked></div>
    <div class="debug-group"><label>GLITCH_EFFECTS</label><input type="checkbox" id="check-glitch" checked></div>
    <div class="debug-group"><label>DANCERS (NPCs)</label><input type="checkbox" id="check-dancers" checked></div>

    <h3 style="color:var(--good)">CLUB_DECOR (OBJECTS)</h3>
    <div class="debug-group"><label>DJ_BOOTH</label><input type="checkbox" id="check-dj" checked></div>
    <div class="debug-group"><label>BARTENDER</label><input type="checkbox" id="check-barman" checked></div>
    <div class="debug-group"><label>VIP_SOFAS</label><input type="checkbox" id="check-sofas" checked></div>
    <div class="debug-group"><label>TABLES</label><input type="checkbox" id="check-tables" checked></div>

    <h3 style="color:var(--excellent)">NEW_DECOR_V2 (FX)</h3>
    <div class="debug-group"><label>LASER_BEAMS</label><input type="checkbox" id="check-lasers" checked></div>
    <div class="debug-group"><label>LASER_INTENSITY</label><input type="range" id="input-laser-intensity" min="1" max="10" value="5"></div>
    <div class="debug-group"><label>SMOKE_MACHINE</label><input type="checkbox" id="check-smoke-machine" checked></div>
    <div class="debug-group"><label>STROBE_LIGHTS</label><input type="checkbox" id="check-strobe" checked></div>
    <div class="debug-group"><label>STROBE_FREQUENCY</label><input type="range" id="input-strobe-freq" min="1" max="8" value="4"></div>
    <div class="debug-group"><label>FLOOR_NEON</label><input type="checkbox" id="check-neon" checked></div>
    <div class="debug-group"><label>NEON_COLOR</label>
        <select id="select-neon-color">
            <option value="#ff00ff">MAGENTA</option>
            <option value="#00ffff">CIAN</option>
            <option value="#00ff00">VERDE</option>
            <option value="#ffff00">AMARILLO</option>
        </select>
    </div>
    
    <!-- NUEVA SECCI√ìN: FEEDBACK SENSORIAL -->
    <h3 style="color:var(--player-color)">FEEDBACK SENSORIAL</h3>
    <div class="debug-group">
        <label>SCREEN SHAKE</label>
        <select id="select-shake-mode">
            <option value="off">OFF</option>
            <option value="sutil" selected>SUTIL (BEAT)</option>
            <option value="intenso">INTENSO (KICK)</option>
            <option value="on_move">ON MOVE</option>
        </select>
    </div>
    <div class="debug-group">
        <label>SHAKE INTENSITY</label>
        <input type="range" id="input-shake-intensity" min="0" max="20" value="5">
    </div>
    <div class="debug-group">
        <label>VIBRATION MOBILE</label>
        <input type="checkbox" id="check-vibration" checked>
    </div>
    
    <!-- NUEVA SECCI√ìN: C√ÅMARA RPG -->
    <h3 style="color:var(--player-color)">C√ÅMARA RPG</h3>
    <div class="debug-group">
        <label>C√ÅMARA CENTRADA</label>
        <input type="checkbox" id="check-camera-centered" checked>
    </div>
    <div class="debug-group">
        <label>ZOOM (1.0x)</label>
        <input type="range" id="input-camera-zoom" min="0.5" max="2.0" step="0.1" value="1.0">
    </div>
    <div class="debug-group">
        <label>SUAVIDAD</label>
        <input type="range" id="input-camera-smooth" min="0.01" max="0.5" step="0.01" value="0.1">
    </div>
    
    <!-- NUEVA SECCI√ìN: MAPA ESTRUCTURAL -->
    <h3 style="color:var(--player-color)">MAPA RPG</h3>
    <div class="debug-group">
        <label>MAPA ESTRUCTURAL</label>
        <select id="select-mapa-tipo">
            <option value="procedural">PROCEDURAL (ORIGINAL)</option>
            <option value="estructural">ESTRUCTURAL (ZONAS)</option>
            <option value="hibrido">H√çBRIDO</option>
        </select>
    </div>
    <div class="debug-group">
        <label>INTERPOLACI√ìN MOV</label>
        <input type="checkbox" id="check-interpolacion" checked>
    </div>
    <div class="debug-group">
        <label>REBOTE EL√ÅSTICO</label>
        <input type="checkbox" id="check-rebote-elastic" checked>
    </div>
    
    <h3 style="color:var(--interact-color)">CLUB_GENERATOR</h3>
    <div class="debug-group"><label>GEN_PROCEDURAL</label><input type="checkbox" id="check-procedural" checked></div>
    <div class="debug-group"><label>WALL_DENSITY</label><input type="range" id="input-wall-density" min="10" max="50" value="25"></div>
    <div class="debug-group"><label>SECRETS</label><input type="checkbox" id="check-secrets" checked></div>
    <div class="debug-group"><label>VIP_ZONES</label><input type="checkbox" id="check-vip" checked></div>
    
    <h3 style="color:var(--player-color)">PERFORMANCE</h3>
    <div class="debug-group"><label>HYDRATION_DECAY</label><input type="range" id="input-hydration-decay" min="0.1" max="2.0" step="0.1" value="0.5"></div>
    <div class="debug-group"><label>COMBO_DECAY</label><input type="range" id="input-combo-decay" min="1" max="10" value="3"></div>
    <div class="debug-group"><label>SISTEMA_TEMBLOR</label>
        <select id="select-temblor-mode" onchange="config.temblorMode = this.value">
            <option value="none">NONE</option>
            <option value="always">ALWAYS</option>
            <option value="on_beat">ON BEAT</option>
            <option value="on_move">ON MOVE</option>
        </select>
    </div>
    <div class="debug-group"><label>SHAKE_INTENSITY</label><input type="range" id="input-shake-intensity-legacy" min="1" max="20" value="8"></div>
    <div class="debug-group"><label>VIBRATION_MOBILE</label><input type="checkbox" id="check-vibration-legacy" checked></div>
    <div class="debug-group"><label>ELASTIC_COLLISIONS</label><input type="checkbox" id="check-elastic" checked></div>
    
    <button class="btn" style="border-color:#500; color:#f55; margin-top:10px;" onclick="reiniciarEscena()">_FORCE_RESET_SYSTEM</button>
</div>
    <div id="playlist-panel" class="side-panel">
        <button id="close-playlist" class="btn">_CERRAR_</button>
        <h3 style="color:var(--playlist-color)">AUDIO_SYNC_PRO</h3>
        <div class="debug-group"><label>AUTO_BPM</label><input type="checkbox" id="playlist-auto-bpm" checked></div>
        <div class="debug-group"><label>CHANGE_FREQ</label><input type="range" id="input-pl-freq" min="4" max="64" step="4" value="16"></div>
        <div class="debug-group"><label>KICK_TYPE</label><select id="input-kick-type"><option value="deep">DEEP_SUB</option><option value="tight">TIGHT_POP</option><option value="electro">ELECTRO</option></select></div>
        <div class="debug-group"><label>SNARE_TYPE</label><select id="input-snare-type"><option value="white">WHITE_NOISE</option><option value="brown">BROWN_HEAVY</option><option value="pink">PINK_SHARP</option></select></div>
        <div class="debug-group"><label>SNARE_ENABLED</label><input type="checkbox" id="check-snare-master" checked></div>
    </div>

    <div id="powerup-panel" class="side-panel">
        <button id="close-powerup" class="btn">_CERRAR_</button>
        <h3 style="color:var(--powerup-color)">CHEMICALS_CONFIG</h3>
        <div class="debug-group" style="background: rgba(255,0,0,0.1); border-color: #f00;">
            <label style="color:#ff4444">‚ö†Ô∏è MODE: PURA AG√úITA</label>
            <div style="font-size:8px; color:#888; margin-top:4px;">0 impurities = 50% score bonus</div>
            <input type="checkbox" id="check-pure-mode" onchange="togglePureMode(this.checked)">
        </div>
        <div id="pu-controls-container"></div>
    </div>

    <div id="debug-panel" class="side-panel">
        <button id="close-debug" class="btn">_CERRAR_</button>
        <h3 style="color:var(--player-color)">CYBORG_SYSTEM_V1</h3>
        <div class="debug-group"><label>NPC_COUNT</label><input type="range" id="input-npc" min="1" max="60" value="25"></div>
        <div class="debug-group"><label>IGNITION_RADIUS</label><input type="range" id="input-ignition-radius" min="1" max="10" value="3"></div>
        <div class="debug-group"><label>SYNC_TOLERANCE</label><input type="range" id="input-tol" min="50" max="300" value="100"></div>
        <div class="debug-group"><label>NOTE_SPEED</label><input type="range" id="input-note-speed" min="600" max="1500" step="50" value="900"></div>
        <div class="debug-group"><label>TIMING_WINDOW</label><input type="range" id="input-note-window" min="0.5" max="0.95" step="0.05" value="0.75"></div>
        <div class="debug-group"><label>MANUAL_BPM</label><input type="range" id="input-bpm" min="60" max="250" value="120"></div>
        <div class="debug-group"><label>ELASTIC_COLLISIONS</label><input type="checkbox" id="check-collision-elastic" checked></div>
        <div class="debug-group">
            <label>VISUAL_MODE</label>
            <select id="select-color-mode" onchange="config.npcColorMode = this.value">
                <option value="Cyborg_Standard" selected>‚úì CYBORG_STANDARD</option>
                <option value="Rave_Alternating">RAVE_PULSE</option>
                <option value="Dark_Mode">GLITCH_DARK</option>
            </select>
        </div>


    <div class="debug-group" style="border: 1px solid var(--interact-color); margin-top: 10px; background: rgba(255, 0, 255, 0.05);">
    <label style="color: var(--interact-color)">EXPANSIONES_RPG</label>
    <button class="btn" style="border-color: var(--interact-color); color: var(--interact-color); width: 100%;" onclick="activarParcheSector7()">[ PATCH: SECTOR_7 ]</button>
</div>

        <button class="btn" style="border-color:#500; color:#f55; margin-top:10px;" onclick="reiniciarEscena()">_FORCE_RESET_SYSTEM</button>
    </div>

    <div id="main-view">
        <div id="start-overlay">
            <h1 style="color:var(--player-color); letter-spacing: 5px;">CYBORG CLUB 2777</h1>
            <div id="objective-box" style="font-size: 10px; color: #888; text-align: center; max-width: 500px; border: 1px solid #333; padding: 10px;">
                ‚ö° <span style="color:var(--player-color)">C√çBORG ENTRANTE</span> - SISTEMA DE IGNICI√ìN ACTIVO<br>
                <br>
                <span style="color:var(--player-color)">OBJETIVO PRIMARIO:</span> IGNITAR NPCS APAGADOS (GRIS ‚Üí <span style="color:var(--interact-color)">MAGENTA</span>)<br>
                <span style="color:var(--player-color)">MEC√ÅNICA:</span> COLISI√ìN R√çTMICA + COMBO POR FLUIDEZ<br>
                <span style="color:var(--player-color)">BIOMETR√çA:</span> HIDRATACI√ìN > 20% PARA EVITAR GLITCH<br>
                <br>
                <span style="color:#ff4444">‚ö†Ô∏è ELECCI√ìN MORAL:</span><br>
                ‚Ä¢ <span style="color:#ffff00">CHEMICALS</span> = VENTAJAS TEMPORALES<br>
                ‚Ä¢ <span style="color:var(--player-color)">PURA AG√úITA</span> = BONUS 50% PUNTUACI√ìN<br>
                <br>
                <span style="color:var(--interact-color)">CLUB GENERADO PROCEDURALMENTE - SECRETOS ACTIVOS</span>
            </div>
            <div id="pre-game-pu-list"></div>
            <div style="display:flex; gap:10px; flex-wrap: wrap; justify-content: center;">
                <button id="btn-generate-club" class="btn" style="border-color:var(--player-color)">GEN_CLUB_NUEVO</button>
                <button id="btn-random-pu" class="btn" style="border-color:var(--powerup-color)">RANDOM_CHEMICALS</button>
                <button id="start-btn" class="btn" style="color:var(--player-color); font-size: 16px; border-color: var(--player-color); padding: 15px 40px;">INIT_CYBORG_SESSION</button>
            </div>
        </div>

        <div id="ui-layer">
            <div id="combo-counter">000</div>
            <div id="accuracy-feedback">SYSTEM_CYBORG_READY</div>
        </div>
        
        <div id="game-container">
            <canvas id="zona-juego" width="450" height="350"></canvas>
            <div id="zona-beat">
                <div id="beat-target"></div>
                <!-- DDR - L√çNEA DEL CARRIL -->
                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 1px; background: rgba(255,255,255,0.1); transform: translateY(-50%); z-index: 1;"></div>
            </div>
        </div>
        
        <div id="status-hud">
            <div id="status-label">EFFECT: NONE</div>
            <div style="font-size:9px; color:#00ffff; margin-bottom:4px;">HYDRATION: <span id="hydration-display">100</span>%</div>
            <div class="progress-bar-container"><div id="progress-fill"></div></div>
        </div>
    </div>
    
    <!-- PANEL DE CONTROLES T√ÅCTILES -->
    <div id="touch-controls-panel">
        <div class="touch-btn touch-up">‚Üë</div>
        <div class="touch-btn touch-down">‚Üì</div>
        <div class="touch-btn touch-left">‚Üê</div>
        <div class="touch-btn touch-right">‚Üí</div>
    </div>
    
    <!-- BOT√ìN DE ACCI√ìN T√ÅCTIL (OPCIONAL) -->
    <div id="touch-action-btn">IGNITE</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
        // ============================================
        // CYBORG CLUB 2777 - CORE ENGINE
        // ============================================

        // --- DATA & CONSTANTS ---
        const EFFECTS_LIST = {
            invert_controls: "CONTROLES INVERTIDOS",
            pause_beat: "SKIP_BEAT (8/8)",
            double_tempo: "DOUBLE_STEP (X2)",
            temblor: "TERREMOTO (BEAT)",
            tilt_screen: "MAREO (TILT)",
            invert_colors: "EPILEPSIA (FLASH)",
            off_beat: "OFF-BEAT CHALLENGE"
        };

        const PU_TYPES = {
            'DRINK':  { char: 'üçπ', def: 'invert_controls', color: '#ff4444', desc: "Invierte flechas.", impurity: 1 },
            'CIGS':   { char: 'üö¨', def: 'pause_beat', color: '#aaaaaa', desc: "Beat 8 vac√≠o.", impurity: 1 },
            'PILL':   { char: 'üíä', def: 'double_tempo', color: '#00ffff', desc: "Salto doble.", impurity: 1 },
            'WEED':   { char: 'üåø', def: 'tilt_screen', color: '#00ff00', desc: "Pantalla torcida.", impurity: 1 },
            'SHADES': { char: 'üï∂Ô∏è', def: 'invert_colors', color: '#ffffff', desc: "Efecto flash.", impurity: 1 },
            'MUSH':   { char: 'üçÑ', def: 'off_beat', color: '#ff00ff', desc: "Doble nota.", impurity: 1 },
            'WATER': { char: 'üíß', def: 'recuperacion', color: '#00ffff', desc: "Recupera hidrataci√≥n.", impurity: 0 }
        };

        // --- SKINS DE 3 CARACTERES ---
        const SKINS = {
            player: {
                head: ['(‚åê‚ñ†_‚ñ†)', '(^o^)', '(‚óï‚Äø‚óï)', 'd(-_-)b'],
                torso: ' || ',
                legs: '/ \\'
            },
            npc_inactive: {  // NPCs APAGADOS (gris)
                head: '(‡≤†_‡≤†)',
                torso: ' || ',
                legs: '/ \\',
                color: '#666666'
            },
            npc_ignited: {  // NPCs ENCENDIDOS (magenta)
                head: '(*^œâ^*)',
                torso: ' || ',
                legs: '/ \\',
                color: '#ff00ff'
            },
            npc_following: {
                head: '(‚Ä¢_‚Ä¢)>',
                torso: ' || ',
                legs: '/ \\',
                color: '#ffa500'
            },
            bartender: {
                head: '(‡≤†_‡≤†)',
                torso: '|Êó¶|',
                legs: '/ \\',
                color: '#aaa'
            },
            dj_state0: {
                head: '(‚åê‚ñ†_‚ñ†)',
                torso: '|„Éé|',
                legs: '/ \\',
                color: '#00ffff'
            },
            dj_state1: {
                head: '(‚åê‚ñ†_‚ñ†)',
                torso: '|‚îõ|',
                legs: '/ \\',
                color: '#00ffff'
            },
            dancer_state0: {
                head: '\\o/',
                torso: ' | ',
                legs: '/ \\',
                color: '#ff00ff'
            },
            dancer_state1: {
                head: ' o ',
                torso: '/|\\',
                legs: '/ \\',
                color: '#ff00ff'
            }
        };

        // --- CYBORG STATE ---
        let canvas, ctx, kick, snare, kickVolume, snareVolume;
        // --- CONFIGURACI√ìN ACTUALIZADA 2777-RPG-v18 ---
let config = {
    grid: 25,                   // input-grid: 22
    bpm: 145,                  // 
    tolerance: 192,            // input-tol: 192
    collision: true,           // check-collision-elastic: true
    npcCount: 25,               // input-npc: 6
    followRadius: 9, 
    kickType: 'deep',          // input-kick-type: "deep"
    showHints: false,          // check-hints: false
    snareEnabled: true,        // check-snare-master: true
    noteSpeed: 900,            // input-note-speed: 900
    noteWindow: 0.75,          // input-note-window: 0.75
    npcColorMode: 'Cyborg_Standard', // select-color-mode
    ignitionRadius: 2,         // input-ignition-radius: 2
    hydrationDecay: 0.2,       // input-hydration-decay: 0.2
    comboDecayRate: 3,         // input-combo-decay: 3
    elasticCollisions: true,   // check-elastic: true
    proceduralGen: false,      // check-procedural: false
    wallDensity: 25,           // input-wall-density: 25
    secretsEnabled: true,      // check-secrets: true
    shakeMode: 'on_beat',      // select-temblor-mode: "on_beat"
    shakeIntensity: 3,         // input-shake-intensity: 3
    vibrationEnabled: true,     // check-vibration: true
	proceduralGen: false,   // ‚ö†Ô∏è CAMBIO: false activa el MAPA ESTRUCTURAL
    mapaTipo: 'estructural' // Fuerza el modo por zonas
};
        
        let appearance = { 
            dj: true, barman: true, sofas: true, tables: true, screens: true, 
            sidebars: true, smoking: true, wc: true, avatar: '(‚åê‚ñ†_‚ñ†)', playerGlow: false,
            djTable: true, 
            dancers: true,
            glitchEffects: true,        // Efectos glitch
            procedural: false,           // Generaci√≥n procedural
            secrets: true,              // Mostrar secretos
            vipZones: true,             // Zonas VIP
            // NUEVOS ELEMENTOS DECORATIVOS
            lasers: true,               // Rayos l√°ser
            laserIntensity: 5,          // Intensidad del l√°ser (1-10)
            smokeMachine: true,         // M√°quina de humo
            strobeLights: true,         // Luces estrobosc√≥picas
            strobeFrequency: 4,         // Frecuencia del strobe (1-8)
            neonFloor: true,            // Ne√≥n en el piso
            neonColor: '#ff00ff'        // Color del ne√≥n
        };
        
        let currentStatus = { type: null, label: 'NONE', beats: 0, maxBeats: 0 };
        let player = { 
            x: 5, 
            y: 5, 
            color: '#00ffff',           // CIAN fijo para jugador
            dir: 1,
            hydration: 100,             // Biometr√≠a ciborg
            impurity: 0,                // Contador de impurezas (chemicals)
            lastMoveBeat: 0,            // √öltimo beat en que se movi√≥
            comboStreak: 0,             // Racha de combo actual
            styleRating: 'S',           // Calificaci√≥n de estilo (S, A, B, C...)
            pureMode: false,            // Modo "Pura Ag√ºita" activo
            lastX: 5,                   // Posici√≥n anterior para detecci√≥n de movimiento
            lastY: 5
        };
        
        let npcs = [], obstacles = [], activeNotes = [], activePowerUpsOnMap = [], puConfig = {};
        let blueZone = { x: 14, y: 13, w: 8, h: 8 };
        let combo = 0, isStarted = false, beatCounter = 0, canMove = false, djStep = 0;
        let dancers = [];
        let secrets = [];               // Secretos del club
        let vipZones = [];              // Zonas VIP
        let lastHydrationCheck = 0;
        let hudVisible = true;          // Estado del HUD
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Elementos decorativos din√°micos
        let laserBeams = [];
        let smokeParticles = [];
        let neonLines = [];
        let strobeFlash = false;
        
        // Estad√≠sticas del jugador
        let playerStats = {
            npcsIgnited: 0,
            secretsFound: 0,
            maxCombo: 0,
            totalMoves: 0,
            perfectMoves: 0,
            timeInClub: 0,
            pureRun: true
        };
        
        // Sistema de evaluaci√≥n de estilo
        const STYLE_THRESHOLDS = {
            S: { minCombo: 50, minIgnited: 20, minPerfect: 0.7, bonus: 2.0 },
            A: { minCombo: 30, minIgnited: 15, minPerfect: 0.5, bonus: 1.5 },
            B: { minCombo: 20, minIgnited: 10, minPerfect: 0.3, bonus: 1.2 },
            C: { minCombo: 10, minIgnited: 5, minPerfect: 0.1, bonus: 1.0 },
            D: { minCombo: 0, minIgnited: 0, minPerfect: 0.0, bonus: 0.8 }
        };

        // VARIABLES PARA CONTROLES M√ìVILES
        let isMobileMode = false;
        let isFullscreen = false;

        // ============================================
        // SISTEMA RPG/DUNGEON DANCE - NUEVAS VARIABLES
        // ============================================
        
        // A. SISTEMA DE INTERPOLACI√ìN (Movimiento Suave)
        let renderData = {
            player: { renderX: 5, renderY: 5, targetX: 5, targetY: 5 },
            npcs: new Map(), // Mapa para interpolaci√≥n de NPCs
            interpolationSpeed: 0.2
        };
        
        // B. SISTEMA DE REBOTE EL√ÅSTICO
        let reboteActivo = false;
        let reboteOffset = { x: 0, y: 0 };
        let tiempoRebote = 0;
        
        // C. SISTEMA DE SHAKE Y VIBRACI√ìN CONFIGURABLE
        const shakeConfig = {
            enabled: true,
            intensity: 5, // 1-10
            mode: 'sutil', // 'off', 'sutil', 'intenso', 'on_move'
            lastShake: 0
        };
        
        const vibrationConfig = {
            enabled: true,
            intensity: 50, // ms
            pattern: [30, 20, 30],
            lastVibration: 0
        };
        
        // D. SISTEMA DE C√ÅMARA RPG
        const cameraConfig = {
            centered: false,
            zoom: 1.0,
            minZoom: 0.5,
            maxZoom: 2.0,
            smoothness: 0.1,
            offsetX: 0,
            offsetY: 0,
            targetOffsetX: 0,
            targetOffsetY: 0,
		adaptive: true
        };
        
        // E. SISTEMA DE MAPA ESTRUCTURAL
        let mapaTipo = 'estructural'; // 'procedural', 'estructural', 'hibrido'
        let interpolacionHabilitada = false;
        let reboteElasticoHabilitado = true;

        // --- INITIALIZATION ---
        
        // --- SISTEMA DE CARGA COMPATIBLE CON ARCHIVOS LOCALES ---
        function cargarParcheExterno() {
            return new Promise((resolve) => {
                const script = document.createElement('script');
                script.src = 'patch_extension.js';
                
                // Si el archivo carga con √©xito
                script.onload = () => {
                    console.log("‚úÖ Parche externo aplicado con √©xito.");
                    resolve();
                };

                // Si el archivo no existe o hay error de seguridad
                script.onerror = () => {
                    console.warn("‚ö†Ô∏è No se pudo cargar patch_extension.js (puede que no exista). Usando configuraci√≥n base.");
                    resolve();
                };

                document.head.appendChild(script);
            });
        }

        // Reemplazo del window.onload para que espere al parche
        window.onload = async () => {
            // 1. Inicializaci√≥n normal del juego
            canvas = document.getElementById('zona-juego');
            ctx = canvas.getContext('2d');
            
            // Inicializar Power-ups
            Object.keys(PU_TYPES).forEach(id => {
                puConfig[id] = { 
                    effect: PU_TYPES[id].def, 
                    rate: 15, 
                    dur: 16, 
                    last: Date.now(), 
                    enabled: true,
                    impurity: PU_TYPES[id].impurity || 0
                };
            });

            // Funciones que estaban faltando
            function renderPreGameMenu() {
                const container = document.getElementById('pre-game-pu-list'); container.innerHTML = "";
                Object.keys(PU_TYPES).forEach(id => {
                    const div = document.createElement('div');
                    div.innerHTML = `<label style="color:${PU_TYPES[id].color}"><input type="checkbox" id="pre-${id}" ${puConfig[id].enabled?'checked':''}> ${PU_TYPES[id].char} ${id}</label>`;
                    container.appendChild(div);
                    document.getElementById(`pre-${id}`).onchange = (e) => puConfig[id].enabled = e.target.checked;
                });
            }

            function initPowerUpMenu() {
                const container = document.getElementById('pu-controls-container'); container.innerHTML = "";
                Object.keys(PU_TYPES).forEach(id => {
                    const div = document.createElement('div'); div.className = 'debug-group';
                    div.innerHTML = `
                        <label style="color:${PU_TYPES[id].color}">${id} <input type="checkbox" ${puConfig[id].enabled?'checked':''} onchange="puConfig['${id}'].enabled=this.checked"></label>
                        <select onchange="puConfig['${id}'].effect=this.value">
                            ${Object.keys(EFFECTS_LIST).map(eff => `<option value="${eff}" ${puConfig[id].effect===eff?'selected':''}>${EFFECTS_LIST[eff]}</option>`).join('')}
                        </select>
                    `;
                    container.appendChild(div);
                });
            }

            function updateKickParams() {
                if (!kick) return;
                if (config.kickType === 'deep') kick.set({ pitchDecay: 0.08, octaves: 5 });
                else if (config.kickType === 'tight') kick.set({ pitchDecay: 0.02, octaves: 2 });
                else kick.set({ pitchDecay: 0.1, octaves: 10 });
            }

            // Helper function to check if position is occupied by another NPC
            function isNPCOccupied(x, y, selfNpc) {
                if (typeof config.npcCollision === 'undefined' || !config.npcCollision) return false;
                return npcs.some(n => n !== selfNpc && n.x === x && n.y === y);
            }

            // Helper function to check if position is valid for NPC movement (obstacles + other NPCs)
            function isNPCBlocked(x, y, selfNpc) {
                if (isOccupied(x, y)) return true; // Check obstacles and bounds
                if (isNPCOccupied(x, y, selfNpc)) return true; // Check other NPCs
                return false;
            }

            renderPreGameMenu();
            initPowerUpMenu();
            
            // Inicializar todos los sistemas
            generarLayoutProcedural();  // Nueva funci√≥n de generaci√≥n
            reiniciarEscena();
            initMobileControls();
            initCyborgHUD();            // Inicializar HUD ciborg
            initDecorations();          // Inicializar elementos decorativos
            setupHudToggle();           // Configurar toggle del HUD
            
            // Inicializar sistema RPG/Dungeon Dance
            inicializarSistemaRPG();
            
            requestAnimationFrame(draw);
            
            // 2. Ahora cargar el parche DESPU√âS de que todo est√© inicializado
            await cargarParcheExterno();
            
            // 3. Inicializar sistema de historia si existe
            if (window.STORY && window.STORY.active) {
                console.log("üé¨ Sistema de historia cargado");
            }
            
            // 4. Exponer variables para el parche
            window.npcs = npcs;
            window.player = player;
            window.obstacles = obstacles;
            window.dancers = dancers;
            window.blueZone = blueZone;
            window.powerUps = activePowerUpsOnMap;
            window.playerHydration = player.hydration;
            window.playerStats = playerStats;
            window.secrets = secrets;
            
            console.log("‚ö° CYBORG CLUB 2777 - Sistema cargado");
        };

        // ============================================
        // SISTEMA RPG/DUNGEON DANCE - FUNCIONES PRINCIPALES
        // ============================================
        
        /**
         * INICIALIZAR SISTEMA RPG COMPLETO
         * Integra todas las nuevas funcionalidades de manera no invasiva
         */
        function inicializarSistemaRPG() {
            console.log("üöÄ Inicializando Sistema 2777 - Modo RPG/Dungeon Dance");
            
            // Preservar estado original
            const estadoOriginal = {
                draw: window.draw,
                onkeydown: window.onkeydown,
                obstacles: [...obstacles],
                config: { ...config }
            };
            
            try {
                // Configurar bindings para nuevos controles
                configurarBindingsRPG();
                
                // Inicializar interpolaci√≥n
                inicializarInterpolacion();
                
                // Inicializar sistema de c√°mara
                inicializarSistemaCamara();
                
                // Inicializar sistema de shake/vibration
                inicializarSistemaShake();
                
                console.log("‚úÖ Sistema RPG/Dungeon Dance inicializado correctamente");
                console.log("üìä Estado: Interpolaci√≥n ‚úÖ | C√°mara RPG ‚úÖ | Shake/Vibrate ‚úÖ | Colisiones el√°sticas ‚úÖ");
                
            } catch (error) {
                console.error("‚ö†Ô∏è Error en inicializaci√≥n RPG, restaurando estado original", error);
                
                // RESTAURACI√ìN DE SEGURIDAD
                window.draw = estadoOriginal.draw;
                window.onkeydown = estadoOriginal.onkeydown;
                obstacles = estadoOriginal.obstacles;
                Object.assign(config, estadoOriginal.config);
                
                console.log("üîÑ Estado original restaurado por seguridad");
            }
        }
        
        /**
         * CONFIGURAR BINDINGS PARA CONTROLES RPG
         */
        function configurarBindingsRPG() {
            // Bindings para nuevos controles en panel de apariencia
            bind('select-mapa-tipo', null, null, (e) => {
                mapaTipo = e.target.value;
                if (mapaTipo === 'estructural') {
                    generarMapaEstructural(config.grid);
                } else if (mapaTipo === 'procedural') {
                    generarLayoutProcedural();
                } else {
                    generarMapaHibrido(config.grid);
                }
                reiniciarEscena();
            });
            
            bind('check-interpolacion', null, null, (e) => {
                interpolacionHabilitada = e.target.checked;
                console.log(`Interpolaci√≥n ${interpolacionHabilitada ? 'activada' : 'desactivada'}`);
            });
            
            bind('check-rebote-elastic', null, null, (e) => {
                reboteElasticoHabilitado = e.target.checked;
                console.log(`Rebote el√°stico ${reboteElasticoHabilitado ? 'activado' : 'desactivado'}`);
            });
            
            bind('check-camera-centered', cameraConfig, 'centered');
            bind('input-camera-zoom', cameraConfig, 'zoom', () => {
                // Actualizar label del zoom
                const zoomLabel = document.querySelector('label[for="input-camera-zoom"]');
                if (zoomLabel) {
                    zoomLabel.textContent = `ZOOM (${cameraConfig.zoom.toFixed(1)}x)`;
                }
            });
            bind('input-camera-smooth', cameraConfig, 'smoothness');
            
            bind('select-shake-mode', shakeConfig, 'mode');
            bind('input-shake-intensity', shakeConfig, 'intensity');
            bind('check-vibration', vibrationConfig, 'enabled');
        }
        
        /**
         * FUNCI√ìN NUEVA: generarMapaEstructural()
         * Genera un layout de club con zonas definidas
         */
        function generarMapaEstructural(gridSize) {
            console.log("üèóÔ∏è Generando mapa estructural con zonas definidas");
            
            // Guardar obst√°culos originales para preservar decoraciones
            const obstaclesOriginales = [...obstacles];
            obstacles = [];
            
            const g = gridSize;
            
            // 1. ZONIFICACI√ìN INTELIGENTE
            const zonas = {
                dJArea: { x: Math.floor(g * 0.8), y: Math.floor(g * 0.1), w: 5, h: 5 },
                pistaCentral: { x: Math.floor(g * 0.3), y: Math.floor(g * 0.3), w: 14, h: 14 },
                barraNorte: { x: Math.floor(g * 0.1), y: Math.floor(g * 0.1), w: 8, h: 3 },
                barraSur: { x: Math.floor(g * 0.1), y: Math.floor(g * 0.7), w: 8, h: 3 },
                vipZones: [
                    { x: Math.floor(g * 0.7), y: Math.floor(g * 0.7), w: 4, h: 4 }
                ]
            };
            
            // 2. PAREDES PERIMETRALES CONTINUAS (no bloques aislados)
            for (let x = 0; x < g; x++) {
                for (let y = 0; y < g; y++) {
                    // Solo bordes y algunas paredes internas estrat√©gicas
                    const esBorde = x === 0 || x === g-1 || y === 0 || y === g-1;
                    const esParedInterna = (
                        (x === Math.floor(g * 0.5) && y > 10 && y < g-10) ||
                        (y === Math.floor(g * 0.5) && x > 10 && x < g-10)
                    );
                    
                    if (esBorde || esParedInterna) {
                        // Verificar que no sobrescriba obst√°culos existentes
                        const existe = obstaclesOriginales.find(o => o.x === x && o.y === y);
                        if (!existe) {
                            obstacles.push({ x, y, char: '‚ñà', color: '#444', type: 'wall_estructura' });
                        }
                    }
                }
            }
            
            // 3. PRESERVAR DECORACIONES EXISTENTES
            obstaclesOriginales.forEach(obs => {
                if (obs.type && obs.type !== 'wall') {
                    obstacles.push(obs);
                }
            });
            
            // 4. ZONA AZUL (objetivo)
            blueZone = {
                x: Math.floor(g * 0.4),
                y: Math.floor(g * 0.4),
                w: Math.floor(g * 0.2) + 2,
                h: Math.floor(g * 0.2) + 2
            };
            
            console.log("üèóÔ∏è Mapa estructural generado con zonas definidas");
        }
        
        /**
         * FUNCI√ìN NUEVA: generarMapaHibrido()
         * Combina generaci√≥n procedural con estructura definida
         */
        function generarMapaHibrido(gridSize) {
            console.log("üîÄ Generando mapa h√≠brido");
            
            // Primero generar mapa estructural
            generarMapaEstructural(gridSize);
            
            // Luego a√±adir algunos elementos procedurales
            const g = gridSize;
            const elementosProcedurales = Math.floor(g * g * 0.1); // 10% del mapa
            
            for (let i = 0; i < elementosProcedurales; i++) {
                const x = Math.floor(Math.random() * (g-2)) + 1;
                const y = Math.floor(Math.random() * (g-2)) + 1;
                
                // Solo a√±adir si no est√° ocupado y no es cerca del centro
                const distAlCentro = Math.sqrt(Math.pow(x - g/2, 2) + Math.pow(y - g/2, 2));
                if (!isOccupied(x, y) && distAlCentro > g/4) {
                    obstacles.push({ x, y, char: '‚ñí', color: '#555', type: 'wall_procedural' });
                }
            }
            
            console.log("üîÄ Mapa h√≠brido generado");
        }
        
        /**
         * INICIALIZAR SISTEMA DE INTERPOLACI√ìN
         */
        function inicializarInterpolacion() {
            // Inicializar posiciones de render
            renderData.player.renderX = player.x;
            renderData.player.renderY = player.y;
            renderData.player.targetX = player.x;
            renderData.player.targetY = player.y;
            
            // Inicializar NPCs
            npcs.forEach((npc, index) => {
                renderData.npcs.set(index, {
                    renderX: npc.x,
                    renderY: npc.y,
                    targetX: npc.x,
                    targetY: npc.y
                });
            });
            
            console.log("üîÑ Sistema de interpolaci√≥n inicializado");
        }
        
        /**
         * ACTUALIZAR POSICIONES DE RENDER INTERPOLADAS
         */
        function actualizarRenderPositions() {
            if (!interpolacionHabilitada || !isStarted) return;
            
            // INTERPOLACI√ìN DEL JUGADOR
            if (renderData.player.targetX !== player.x || renderData.player.targetY !== player.y) {
                renderData.player.targetX = player.x;
                renderData.player.targetY = player.y;
            }
            
            // Aplicar LERP (Linear Interpolation)
            const dx = renderData.player.targetX - renderData.player.renderX;
            const dy = renderData.player.targetY - renderData.player.renderY;
            
            if (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01) {
                renderData.player.renderX += dx * renderData.interpolationSpeed;
                renderData.player.renderY += dy * renderData.interpolationSpeed;
            }
            
            // INTERPOLACI√ìN DE NPCS
            npcs.forEach((npc, index) => {
                if (!renderData.npcs.has(index)) {
                    renderData.npcs.set(index, {
                        renderX: npc.x,
                        renderY: npc.y,
                        targetX: npc.x,
                        targetY: npc.y
                    });
                }
                
                const npcRender = renderData.npcs.get(index);
                npcRender.targetX = npc.x;
                npcRender.targetY = npc.y;
                
                const ndx = npcRender.targetX - npcRender.renderX;
                const ndy = npcRender.targetY - npcRender.renderY;
                
                if (Math.abs(ndx) > 0.01 || Math.abs(ndy) > 0.01) {
                    npcRender.renderX += ndx * renderData.interpolationSpeed;
                    npcRender.renderY += ndy * renderData.interpolationSpeed;
                }
            });
        }
        
        /**
         * SISTEMA DE COLISI√ìN CON REBOTE EL√ÅSTICO
         */
        function verificarColisionConRebote(nx, ny) {
            const colisionOriginal = isOccupied(nx, ny);
            
            if (colisionOriginal && reboteElasticoHabilitado && config.elasticCollisions) {
                // DETECTAR COLISI√ìN PERO NO PENALIZAR COMBO
                if (isStarted && canMove) {
                    // Activar efecto de rebote visual
                    reboteActivo = true;
                    tiempoRebote = 10; // frames
                    
                    // Calcular direcci√≥n de rebote
                    const dx = nx - player.x;
                    const dy = ny - player.y;
                    reboteOffset = { x: -dx * 0.3, y: -dy * 0.3 };
                    
                    // FEEDBACK VISUAL SIN AFECTAR COMBO
                    const feedback = document.getElementById('accuracy-feedback');
                    if (feedback && combo > 0) {
                        feedback.innerText = "IMPACTO! (COMBO PROTEGIDO)";
                        feedback.style.color = "#ffff00";
                        
                        // Restaurar mensaje original despu√©s de 0.5s
                        setTimeout(() => {
                            if (feedback.innerText === "IMPACTO! (COMBO PROTEGIDO)") {
                                feedback.innerText = "SYNC_MANTENIDO";
                                feedback.style.color = "var(--excellent)";
                            }
                        }, 500);
                    }
                    
                    console.log("üîµ Colisi√≥n el√°stica detectada - Combo preservado");
                }
                
                return true;
            }
            
            return colisionOriginal;
        }
        
        /**
         * ACTUALIZAR SISTEMA DE REBOTE
         */
        function actualizarSistemaRebote() {
            if (reboteActivo && tiempoRebote > 0) {
                tiempoRebote--;
                
                // Reducir offset gradualmente
                reboteOffset.x *= 0.85;
                reboteOffset.y *= 0.85;
                
                if (tiempoRebote <= 0) {
                    reboteActivo = false;
                    reboteOffset = { x: 0, y: 0 };
                }
            }
        }
        
        /**
         * INICIALIZAR SISTEMA DE C√ÅMARA
         */
        function inicializarSistemaCamara() {
            // Guardar funci√≥n draw original
            const drawOriginal = window.draw;
            
            // Crear wrapper para draw con sistema de c√°mara
            window.draw = function() {
                const canvas = document.getElementById('zona-juego');
                const ctx = canvas.getContext('2d');
                
                // Guardar estado del contexto
                ctx.save();
                
                // Aplicar transformaciones de c√°mara si est√° centrada
                if (cameraConfig.centered && isStarted) {
                    const cellSize = canvas.width / config.grid;
                    
                    // Calcular posici√≥n del jugador en pantalla
                    const playerScreenX = (interpolacionHabilitada ? renderData.player.renderX : player.x) * cellSize;
                    const playerScreenY = (interpolacionHabilitada ? renderData.player.renderY : player.y) * cellSize;
                    
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Calcular offset para centrar jugador
                    cameraConfig.targetOffsetX = centerX - playerScreenX;
                    cameraConfig.targetOffsetY = centerY - playerScreenY;
                    
                    // Interpolar offset para suavidad
                    const dx = cameraConfig.targetOffsetX - cameraConfig.offsetX;
                    const dy = cameraConfig.targetOffsetY - cameraConfig.offsetY;
                    
                    cameraConfig.offsetX += dx * cameraConfig.smoothness;
                    cameraConfig.offsetY += dy * cameraConfig.smoothness;
                    
                    // Aplicar transformaci√≥n
                    ctx.translate(cameraConfig.offsetX, cameraConfig.offsetY);
                    ctx.scale(cameraConfig.zoom, cameraConfig.zoom);
                }
                
                // Ejecutar draw original con transformaciones aplicadas
                if (typeof drawOriginal === 'function') {
                    drawOriginal();
                }
                
                // Restaurar estado del contexto
                ctx.restore();
            };
            
            console.log("üé• Sistema de c√°mara RPG inicializado");
        }
        
        /**
         * INICIALIZAR SISTEMA DE SHAKE/VIBRATION
         */
        function inicializarSistemaShake() {
            console.log("üì≥ Sistema de shake/vibration inicializado");
        }
        
        /**
         * APLICAR SCREEN SHAKE
         */
        function aplicarScreenShakeRPG() {
            if (!shakeConfig.enabled || !isStarted) return;
            
            const gameContainer = document.getElementById('game-container');
            if (!gameContainer) return;
            
            let shouldShake = false;
            
            switch(shakeConfig.mode) {
                case 'sutil':
                    shouldShake = (beatCounter % 4 === 0); // Cada 4 beats
                    break;
                case 'intenso':
                    shouldShake = (beatCounter % 2 === 0); // Cada 2 beats
                    break;
                case 'on_move':
                    shouldShake = (player.lastMoveBeat === beatCounter);
                    break;
                case 'off':
                    shouldShake = false;
                    break;
                default:
                    shouldShake = false;
            }
            
            if (shouldShake && Date.now() - shakeConfig.lastShake > 100) {
                const intensity = shakeConfig.intensity;
                const shakeX = (Math.random() - 0.5) * intensity;
                const shakeY = (Math.random() - 0.5) * intensity;
                
                // Aplicar shake adem√°s de cualquier transformaci√≥n existente
                const currentTransform = gameContainer.style.transform || '';
                gameContainer.style.transform = `${currentTransform} translate(${shakeX}px, ${shakeY}px)`;
                shakeConfig.lastShake = Date.now();
                
                // Restaurar despu√©s de 50ms
                setTimeout(() => {
                    gameContainer.style.transform = currentTransform;
                }, 50);
            }
        }
        
        /**
         * ACTIVAR VIBRACI√ìN
         */
        function activarVibracionRPG() {
            if (!vibrationConfig.enabled || !isMobile || !navigator.vibrate) return;
            
            if (beatCounter % 2 === 0 && Date.now() - vibrationConfig.lastVibration > 200) {
                if (vibrationConfig.pattern) {
                    navigator.vibrate(vibrationConfig.pattern);
                } else {
                    navigator.vibrate(vibrationConfig.intensity);
                }
                vibrationConfig.lastVibration = Date.now();
            }
        }

        // ============================================
        // NUEVO: INICIALIZACI√ìN DE ELEMENTOS DECORATIVOS
        // ============================================
        
        function initDecorations() {
            // Configurar bindings para elementos decorativos
            bind('check-lasers', appearance, 'lasers', updateDecorations);
            bind('input-laser-intensity', appearance, 'laserIntensity', updateDecorations);
            bind('check-smoke-machine', appearance, 'smokeMachine', updateDecorations);
            bind('check-strobe', appearance, 'strobeLights', updateDecorations);
            bind('input-strobe-freq', appearance, 'strobeFrequency', updateDecorations);
            bind('check-neon', appearance, 'neonFloor', updateDecorations);
            bind('select-neon-color', appearance, 'neonColor', () => {
                appearance.neonColor = document.getElementById('select-neon-color').value;
                updateDecorations();
            });
            
            // Configurar shake
            bind('select-temblor-mode', config, 'temblorMode');
            bind('input-shake-intensity-legacy', config, 'shakeIntensity');
            bind('check-vibration-legacy', config, 'vibrationEnabled');
            
            updateDecorations();
        }
        
        function updateDecorations() {
            // Reinicializar elementos decorativos seg√∫n configuraci√≥n
            laserBeams = [];
            smokeParticles = [];
            neonLines = [];
            
            const g = config.grid;
            
            // Crear l√°seres si est√°n activados
            if (appearance.lasers) {
                // L√°seres horizontales
                for (let i = 0; i < appearance.laserIntensity; i++) {
                    const y = Math.floor(Math.random() * (g-4)) + 2;
                    laserBeams.push({
                        x1: 2,
                        x2: g-3,
                        y: y,
                        color: i % 3 === 0 ? '#ff00ff' : i % 3 === 1 ? '#00ffff' : '#ffff00',
                        width: 1 + Math.random() * 2,
                        pulse: Math.random() * Math.PI * 2
                    });
                }
                
                // L√°seres verticales
                for (let i = 0; i < appearance.laserIntensity; i++) {
                    const x = Math.floor(Math.random() * (g-4)) + 2;
                    laserBeams.push({
                        x: x,
                        y1: 2,
                        y2: g-3,
                        color: i % 3 === 0 ? '#ff00ff' : i % 3 === 1 ? '#00ffff' : '#ffff00',
                        width: 1 + Math.random() * 2,
                        pulse: Math.random() * Math.PI * 2,
                        vertical: true
                    });
                }
            }
            
            // Crear l√≠neas de ne√≥n si est√°n activadas
            if (appearance.neonFloor) {
                // L√≠neas horizontales
                for (let y = 2; y < g-2; y += 4) {
                    neonLines.push({
                        x1: 2,
                        x2: g-3,
                        y: y,
                        color: appearance.neonColor,
                        width: 1
                    });
                }
                
                // L√≠neas verticales
                for (let x = 2; x < g-2; x += 6) {
                    neonLines.push({
                        x: x,
                        y1: 2,
                        y2: g-3,
                        color: appearance.neonColor,
                        width: 1,
                        vertical: true
                    });
                }
            }
        }
        
        function updateStrobe() {
            if (!appearance.strobeLights) return;
            
            // Actualizar estado del strobe basado en frecuencia
            const strobeInterval = Math.floor(8 / appearance.strobeFrequency);
            strobeFlash = (beatCounter % strobeInterval === 0);
        }
        
        function updateSmoke() {
            if (!appearance.smokeMachine) return;
            
            // Generar nuevas part√≠culas de humo aleatoriamente
            if (Math.random() < 0.1) {
                smokeParticles.push({
                    x: Math.random() * config.grid,
                    y: config.grid - 2,
                    size: 2 + Math.random() * 4,
                    opacity: 0.3 + Math.random() * 0.4,
                    speed: 0.5 + Math.random() * 1,
                    drift: (Math.random() - 0.5) * 0.5
                });
            }
            
            // Actualizar part√≠culas existentes
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const p = smokeParticles[i];
                p.y -= p.speed * 0.1;
                p.x += p.drift * 0.1;
                p.opacity -= 0.01;
                p.size -= 0.02;
                
                if (p.opacity <= 0 || p.size <= 0) {
                    smokeParticles.splice(i, 1);
                }
            }
        }
        
        function applyScreenShake() {
            if (config.temblorMode === 'none' || config.shakeIntensity <= 0) {
                document.getElementById('game-container').style.transform = 'none';
                return;
            }
            
            let shouldShake = false;
            
            switch(config.temblorMode) {
                case 'always':
                    shouldShake = true;
                    break;
                case 'on_beat':
                    shouldShake = (beatCounter % 4 === 0); // Shake cada 4 beats
                    break;
                case 'on_move':
                    shouldShake = (player.x !== player.lastX || player.y !== player.lastY);
                    break;
            }
            
            if (shouldShake && isStarted) {
                const intensity = config.shakeIntensity;
                const shakeX = (Math.random() - 0.5) * intensity;
                const shakeY = (Math.random() - 0.5) * intensity;
                document.getElementById('game-container').style.transform = `translate(${shakeX}px, ${shakeY}px)`;
                
                // Aplicar vibraci√≥n si est√° habilitado y es m√≥vil
                if (isMobile && config.vibrationEnabled && navigator.vibrate) {
                    navigator.vibrate(50); // Vibrar por 50ms
                }
            } else {
                document.getElementById('game-container').style.transform = 'none';
            }
            
            // Guardar posici√≥n actual para comparaci√≥n
            player.lastX = player.x;
            player.lastY = player.y;
        }

        // ============================================
        // NUEVO: CONFIGURACI√ìN DEL HUD
        // ============================================
        
        function setupHudToggle() {
            const toggleBtn = document.getElementById('hud-toggle-btn');
            const hud = document.getElementById('cyborg-hud');
            
            if (toggleBtn && hud) {
                toggleBtn.onclick = function() {
                    hudVisible = !hudVisible;
                    if (hudVisible) {
                        hud.style.opacity = '1';
                        toggleBtn.textContent = '‚ñº';
                    } else {
                        hud.style.opacity = '0.3';
                        toggleBtn.textContent = '‚ñ≤';
                    }
                };
            }
        }

        // ============================================
        // NUEVO: SISTEMA DE GENERACI√ìN PROCEDURAL
        // ============================================
        
        function generarLayoutProcedural() {
            obstacles = []; 
            secrets = [];
            vipZones = [];
            
            const g = config.grid;
            
            if (!config.proceduralGen) {
                // Generaci√≥n cl√°sica
                generarLayoutClasico(g);
                return;
            }
            
            console.log(`üé≤ Generando club procedural (${g}x${g}, densidad: ${config.wallDensity}%)`);
            
            // 1. LIMITES EXTERIORES
            for(let x = 0; x < g; x++) {
                obstacles.push({x: x, y: 0, char: '‚ñà', color: '#333', type: 'wall'});
                obstacles.push({x: x, y: g-1, char: '‚ñà', color: '#333', type: 'wall'});
            }
            for(let y = 1; y < g-1; y++) {
                obstacles.push({x: 0, y: y, char: '‚ñà', color: '#333', type: 'wall'});
                obstacles.push({x: g-1, y: y, char: '‚ñà', color: '#333', type: 'wall'});
            }
            
            // 2. PAREDES INTERNAS (procedural)
            const totalCells = g * g;
            const targetWalls = Math.floor(totalCells * (config.wallDensity / 100));
            
            let wallsPlaced = 0;
            let attempts = 0;
            const maxAttempts = targetWalls * 10;
            
            while(wallsPlaced < targetWalls && attempts < maxAttempts) {
                attempts++;
                const x = Math.floor(Math.random() * (g-2)) + 1;
                const y = Math.floor(Math.random() * (g-2)) + 1;
                
                // Verificar que no bloquee todo el paso
                if (!isCellCritical(x, y, g)) {
                    // No colocar paredes demasiado juntas
                    let tooClose = false;
                    for(let dx = -2; dx <= 2 && !tooClose; dx++) {
                        for(let dy = -2; dy <= 2 && !tooClose; dy++) {
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx >= 0 && nx < g && ny >= 0 && ny < g) {
                                const existing = obstacles.find(o => o.x === nx && o.y === ny && o.type === 'wall');
                                if (existing && Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
                                    tooClose = true;
                                }
                            }
                        }
                    }
                    
                    if (!tooClose) {
                        obstacles.push({x, y, char: '‚ñí', color: '#444', type: 'wall'});
                        wallsPlaced++;
                    }
                }
            }
            
            // 3. ZONA AZUL (objetivo) - siempre accesible
            blueZone = {
                x: Math.floor(g * 0.6),
                y: Math.floor(g * 0.6),
                w: Math.floor(g * 0.15) + 2,
                h: Math.floor(g * 0.15) + 2
            };
            
            // Asegurar que la zona azul no tenga paredes
            for(let x = blueZone.x; x < blueZone.x + blueZone.w; x++) {
                for(let y = blueZone.y; y < blueZone.y + blueZone.h; y++) {
                    const wallIndex = obstacles.findIndex(o => o.x === x && o.y === y && o.type === 'wall');
                    if (wallIndex !== -1) {
                        obstacles.splice(wallIndex, 1);
                    }
                }
            }
            
            // 4. SECRETOS (si est√°n habilitados)
            if (appearance.secrets) {
                const numSecrets = Math.floor(g / 8);
                for(let i = 0; i < numSecrets; i++) {
                    let x, y, attempts = 0;
                    do {
                        x = Math.floor(Math.random() * (g-4)) + 2;
                        y = Math.floor(Math.random() * (g-4)) + 2;
                        attempts++;
                    } while((isOccupied(x, y) || isTooCloseToOtherSecret(x, y)) && attempts < 50);
                    
                    if (attempts < 50) {
                        secrets.push({
                            x, y, 
                            discovered: false,
                            type: ['extra_combo', 'hydration_boost', 'style_bonus'][Math.floor(Math.random() * 3)],
                            char: '?',
                            color: '#333333'
                        });
                    }
                }
            }
            
            // 5. ZONAS VIP
            if (appearance.vipZones) {
                const numVip = Math.floor(g / 10);
                for(let i = 0; i < numVip; i++) {
                    let x, y, w, h, attempts = 0;
                    do {
                        x = Math.floor(Math.random() * (g-6)) + 1;
                        y = Math.floor(Math.random() * (g-6)) + 1;
                        w = Math.floor(Math.random() * 3) + 2;
                        h = Math.floor(Math.random() * 2) + 1;
                        attempts++;
                    } while(!isAreaClear(x, y, w, h) && attempts < 30);
                    
                    if (attempts < 30) {
                        vipZones.push({x, y, w, h, entered: false});
                    }
                }
            }
            
            // 6. ELEMENTOS DECORATIVOS (opcionales)
            if (appearance.dj) {
                let djX, djY, attempts = 0;
                do {
                    djX = Math.floor(g * 0.5);
                    djY = Math.floor(g * 0.1);
                    attempts++;
                } while(isOccupied(djX, djY) && attempts < 20);
                if (attempts < 20) obstacles.push({x: djX, y: djY, type: 'dj'});
            }
            
            if (appearance.barman) {
                let barX, barY, attempts = 0;
                do {
                    barX = g-4;
                    barY = Math.floor(g * 0.5);
                    attempts++;
                } while(isOccupied(barX, barY) && attempts < 20);
                if (attempts < 20) obstacles.push({x: barX, y: barY, char: '(‡≤†_‡≤†)Êó¶', color: '#aaa'});
            }
            
            console.log(`üé≤ Club generado: ${wallsPlaced} paredes, ${secrets.length} secretos, ${vipZones.length} zonas VIP`);
        }
        
        function generarLayoutClasico(g) {
            // Layout original del juego base (para compatibilidad)
            blueZone = { x: Math.floor(g*0.4), y: Math.floor(g*0.4), w: Math.floor(g*0.2)+2, h: Math.floor(g*0.2)+2 };
            
            dancers = [];
            if (appearance.dancers) {
                for(let i = 0; i < 5; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * (g-4)) + 2;
                        y = Math.floor(Math.random() * (g-4)) + 2;
                    } while(isOccupied(x, y));
                    dancers.push({ x, y, state: 0, moveCounter: 0 });
                }
            }
            
            if (appearance.dj) obstacles.push({x: Math.floor(g/2), y: 1, type: 'dj'});
            if (appearance.barman) obstacles.push({x: g-3, y: Math.floor(g/2), char: '(‡≤†_‡≤†)Êó¶', color: '#aaa'});
            if (appearance.sofas) {
                for(let i=2; i<6; i++) obstacles.push({x: i, y: g-3, char: 'TTT', color: '#01CDFE'});
            }
            if (appearance.tables) {
                obstacles.push({x: 3, y: g-5, char: '‚î¨‚îÄ‚î¨', color: '#01CDFE'});
            }
            if (appearance.screens) {
                obstacles.push({x: Math.floor(g*0.2), y: 0, char: '[REC]', color: '#500'});
                obstacles.push({x: Math.floor(g*0.8), y: 0, char: '[REC]', color: '#500'});
            }
            if (appearance.sidebars) {
                for(let y=Math.floor(g*0.3); y<Math.floor(g*0.7); y++) obstacles.push({x: 1, y: y, char: '‚ñí', color: '#01CDFE'});
            }
            if (appearance.smoking) obstacles.push({x: g-4, y: g-3, char: '(SS)', color: '#01CDFE'});
            if (appearance.wc) obstacles.push({x: 1, y: g-2, char: '[WC]', color: '#fff'});
            
            if (appearance.djTable) {
                obstacles.push({x: Math.floor(g/2)-1, y: 2, type: 'djTable', char: '‚îå‚îÄ‚îê', color: '#00ffff'});
                obstacles.push({x: Math.floor(g/2), y: 2, type: 'djTable', char: '‚îÇ‚ñå‚îÇ', color: '#00ffff'});
                obstacles.push({x: Math.floor(g/2)+1, y: 2, type: 'djTable', char: '‚îî‚îÄ‚îò', color: '#00ffff'});
            }
        }
        
        function isCellCritical(x, y, gridSize) {
            // Verificar si esta celda es cr√≠tica para la conectividad
            // (simplificado - en producci√≥n usar BFS/DFS)
            return false;
        }
        
        function isTooCloseToOtherSecret(x, y) {
            return secrets.some(s => Math.abs(s.x - x) < 3 && Math.abs(s.y - y) < 3);
        }
        
        function isAreaClear(x, y, w, h) {
            for(let dx = 0; dx < w; dx++) {
                for(let dy = 0; dy < h; dy++) {
                    if (isOccupied(x + dx, y + dy)) {
                        return false;
                    }
                }
            }
            return true;
        }

        // ============================================
        // NUEVO: SISTEMA DE IGNICI√ìN Y F√çSICA CIBORG
        // ============================================
        
        function checkCyborgCollisions() {
            if (!isStarted) return;
            
            // 1. VERIFICAR COLISIONES CON NPCS PARA IGNICI√ìN
            npcs.forEach((npc, index) => {
                const distance = Math.sqrt(Math.pow(npc.x - player.x, 2) + Math.pow(npc.y - player.y, 2));
                
                if (distance <= config.ignitionRadius) {
                    // NPC dentro del radio de ignici√≥n
                    if (!npc.isIgnited) {
                        // IGNITAR NPC
                        npc.isIgnited = true;
                        npc.ignitedAt = beatCounter;
                        npc.color = '#ff00ff';  // MAGENTA
                        npc.char = '(*^œâ^*)';
                        
                        // Aumentar estad√≠sticas
                        playerStats.npcsIgnited++;
                        
                        // Incrementar combo por ignici√≥n
                        combo++;
                        player.comboStreak++;
                        
                        // Actualizar combo m√°ximo
                        if (combo > playerStats.maxCombo) {
                            playerStats.maxCombo = combo;
                        }
                        
                        // Feedback visual
                        document.getElementById('accuracy-feedback').innerText = "IGNITED!";
                        document.getElementById('accuracy-feedback').style.color = "#ff00ff";
                        
                        console.log(`üî• NPC ignited! Total: ${playerStats.npcsIgnited}`);
                    }
                }
                
                // 2. COLISIONES EL√ÅSTICAS (si est√° habilitado)
                if (config.elasticCollisions && distance < 1.5 && distance > 0) {
                    // Colisi√≥n detectada - aplicar rebote el√°stico simple
                    if (npc.x === player.x && npc.y === player.y) {
                        // Mover NPC en direcci√≥n opuesta
                        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                        const [dx, dy] = dirs[Math.floor(Math.random() * 4)];
                        const nx = npc.x + dx;
                        const ny = npc.y + dy;
                        
                        if (!isOccupied(nx, ny) && !isNPCOccupied(nx, ny, npc)) {
                            npc.x = nx;
                            npc.y = ny;
                        }
                    }
                }
            });
            
            // 3. VERIFICAR SECRETOS
            secrets.forEach(secret => {
                if (!secret.discovered && secret.x === player.x && secret.y === player.y) {
                    secret.discovered = true;
                    secret.color = '#00ffff';  // CIAN cuando se descubre
                    playerStats.secretsFound++;
                    
                    // Aplicar bonus seg√∫n tipo de secreto
                    switch(secret.type) {
                        case 'extra_combo':
                            combo += 5;
                            document.getElementById('accuracy-feedback').innerText = "SECRET: +5 COMBO";
                            break;
                        case 'hydration_boost':
                            player.hydration = Math.min(100, player.hydration + 30);
                            updateHydrationDisplay();
                            document.getElementById('accuracy-feedback').innerText = "SECRET: +30 HYDRATION";
                            break;
                        case 'style_bonus':
                            player.comboStreak += 10;
                            document.getElementById('accuracy-feedback').innerText = "SECRET: STYLE BOOST";
                            break;
                    }
                    
                    document.getElementById('accuracy-feedback').style.color = "#00ffff";
                    console.log(`üîç Secret found! Total: ${playerStats.secretsFound}`);
                }
            });
            
            // 4. VERIFICAR ZONAS VIP
            vipZones.forEach(vip => {
                if (!vip.entered && 
                    player.x >= vip.x && player.x < vip.x + vip.w &&
                    player.y >= vip.y && player.y < vip.y + vip.h) {
                    
                    vip.entered = true;
                    combo += 10;
                    document.getElementById('accuracy-feedback').innerText = "VIP ACCESS!";
                    document.getElementById('accuracy-feedback').style.color = "#ffff00";
                }
            });
            
            // 5. ACTUALIZAR COMBO (decaimiento si no hay movimiento)
            if (player.lastMoveBeat > 0 && (beatCounter - player.lastMoveBeat) > config.comboDecayRate) {
                // El jugador no se ha movido en varios beats - reducir combo
                combo = Math.max(0, combo - 1);
                if (combo === 0) {
                    player.comboStreak = 0;
                }
            }
            
            // 6. ACTUALIZAR CALIFICACI√ìN DE ESTILO
            updateStyleRating();
        }
        
        // ============================================
        // NUEVO: SISTEMA DE BIOMETR√çA CIBORG
        // ============================================
        
        function updateCyborgBiometrics() {
            if (!isStarted) return;
            
            // 1. DECAIMIENTO DE HIDRATACI√ìN
            player.hydration = Math.max(0, player.hydration - config.hydrationDecay);
            
            // 2. APLICAR EFECTOS GLITCH SEG√öN HIDRATACI√ìN
            const gameContainer = document.getElementById('game-container');
            
            if (appearance.glitchEffects) {
                gameContainer.classList.remove('glitch-low', 'glitch-critical');
                
                if (player.hydration < 30) {
                    gameContainer.classList.add('glitch-low');
                }
                if (player.hydration < 15) {
                    gameContainer.classList.add('glitch-critical');
                    // Penalizaci√≥n por hidrataci√≥n cr√≠tica
                    config.tolerance = Math.max(50, config.tolerance * 0.8);
                } else {
                    config.tolerance = 100; // Valor normal
                }
            }
            
            // 3. ACTUALIZAR DISPLAY DE HIDRATACI√ìN
            updateHydrationDisplay();
            
            // 4. VERIFICAR MUERTE POR DESHIDRATACI√ìN
            if (player.hydration <= 0) {
                endSession("DEHYDRATION_CRITICAL");
            }
        }
        
        function updateHydrationDisplay() {
            const percentage = document.getElementById('hydration-percentage');
            const fill = document.getElementById('hydration-fill');
            
            const hydValue = Math.floor(player.hydration);
            if (percentage) percentage.textContent = hydValue + '%';
            if (fill) {
                fill.style.width = player.hydration + '%';
                
                // Cambiar color seg√∫n nivel
                if (player.hydration < 20) {
                    fill.style.background = '#ff4444';
                } else if (player.hydration < 50) {
                    fill.style.background = '#ffff00';
                } else {
                    fill.style.background = '#00ffff';
                }
            }
            
            // Actualizar tambi√©n en el status HUD
            const display = document.getElementById('hydration-display');
            if (display) display.textContent = hydValue;
        }
        
        // ============================================
        // NUEVO: SISTEMA DE EVALUACI√ìN DE ESTILO
        // ============================================
        
        function updateStyleRating() {
            // Calcular ratio de movimientos perfectos
            const perfectRatio = playerStats.totalMoves > 0 ? 
                playerStats.perfectMoves / playerStats.totalMoves : 0;
            
            // Determinar calificaci√≥n basada en m√∫ltiples factores
            let newRating = 'D';
            
            if (combo >= STYLE_THRESHOLDS.S.minCombo && 
                playerStats.npcsIgnited >= STYLE_THRESHOLDS.S.minIgnited &&
                perfectRatio >= STYLE_THRESHOLDS.S.minPerfect) {
                newRating = 'S';
            } else if (combo >= STYLE_THRESHOLDS.A.minCombo && 
                      playerStats.npcsIgnited >= STYLE_THRESHOLDS.A.minIgnited &&
                      perfectRatio >= STYLE_THRESHOLDS.A.minPerfect) {
                newRating = 'A';
            } else if (combo >= STYLE_THRESHOLDS.B.minCombo && 
                      playerStats.npcsIgnited >= STYLE_THRESHOLDS.B.minIgnited &&
                      perfectRatio >= STYLE_THRESHOLDS.B.minPerfect) {
                newRating = 'B';
            } else if (combo >= STYLE_THRESHOLDS.C.minCombo && 
                      playerStats.npcsIgnited >= STYLE_THRESHOLDS.C.minIgnited &&
                      perfectRatio >= STYLE_THRESHOLDS.C.minPerfect) {
                newRating = 'C';
            }
            
            // Bonus por modo "Pura Ag√ºita"
            if (player.pureMode && player.impurity === 0) {
                // Aumentar rating si est√° en modo puro
                if (newRating === 'B') newRating = 'A';
                else if (newRating === 'A') newRating = 'S';
                else if (newRating === 'S') newRating = 'S+';
            }
            
            player.styleRating = newRating;
            const styleElement = document.querySelector('#style-rating');
            if (styleElement) {
                styleElement.textContent = newRating;
                styleElement.style.color = newRating === 'S' ? '#ff00ff' : 
                                          newRating === 'A' ? '#00ffff' : 
                                          newRating === 'B' ? '#ffff00' : '#ffffff';
            }
        }
        
        // ============================================
        // NUEVO: FINALIZACI√ìN DE SESI√ìN
        // ============================================
        
        function endSession(reason) {
            if (!isStarted) return;
            
            isStarted = false;
            Tone.Transport.stop();
            if (loop && loop.state === "started") loop.stop();
            if (doubleTempoLoop && doubleTempoLoop.state === "started") doubleTempoLoop.stop();
            
            // Calcular puntuaci√≥n final
            let finalScore = calculateFinalScore();
            
            // Mostrar resultados
            const resultsHTML = `
                <div style="text-align: center; max-width: 500px;">
                    <h2 style="color:var(--player-color); margin-bottom: 20px;">SESSION TERMINATED</h2>
                    <div style="background: rgba(0,0,0,0.8); border: 1px solid var(--player-color); padding: 20px; margin-bottom: 20px;">
                        <div style="color:#ff4444; font-size: 14px; margin-bottom: 10px;">REASON: ${reason}</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; text-align: left;">
                            <div style="color:#888;">NPCs IGNITED:</div><div style="color:var(--interact-color);">${playerStats.npcsIgnited}</div>
                            <div style="color:#888;">MAX COMBO:</div><div style="color:var(--interact-color);">${playerStats.maxCombo}</div>
                            <div style="color:#888;">SECRETS FOUND:</div><div style="color:var(--interact-color);">${playerStats.secretsFound}</div>
                            <div style="color:#888;">TIME IN CLUB:</div><div style="color:var(--interact-color);">${Math.floor(playerStats.timeInClub/60)}m ${playerStats.timeInClub%60}s</div>
                            <div style="color:#888;">STYLE RATING:</div><div style="color:var(--interact-color); font-size: 18px;">${player.styleRating}</div>
                            <div style="color:#888;">IMPURITY LEVEL:</div><div style="color:${player.impurity > 0 ? '#ff4444' : '#00ff00'};">${player.impurity}</div>
                        </div>
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #333;">
                            <div style="color:#888;">FINAL SCORE:</div>
                            <div style="color:var(--player-color); font-size: 32px; margin: 10px 0;">${finalScore.toLocaleString()}</div>
                            ${player.pureMode && player.impurity === 0 ? 
                                `<div style="color:#00ff00; font-size: 12px;">‚ú® PURA AG√úITA BONUS: +50%</div>` : 
                                ''}
                        </div>
                    </div>
                    <button id="restart-btn" class="btn" style="color:var(--player-color); border-color: var(--player-color); padding: 10px 30px;">
                        RE-ENTER CLUB
                    </button>
                </div>
            `;
            
            const overlay = document.getElementById('start-overlay');
            overlay.innerHTML = resultsHTML;
            overlay.style.display = 'flex';
            
            document.getElementById('restart-btn').onclick = () => {
                reiniciarEscena();
                overlay.style.display = 'none';
                startGameSession();
            };
        }
        
        function calculateFinalScore() {
            let score = 0;
            
            // Base por NPCs encendidos
            score += playerStats.npcsIgnited * 100;
            
            // Bonus por combo m√°ximo
            score += playerStats.maxCombo * 50;
            
            // Bonus por secretos
            score += playerStats.secretsFound * 500;
            
            // Bonus por tiempo en club
            score += playerStats.timeInClub * 10;
            
            // Multiplicador por estilo
            const styleBonus = STYLE_THRESHOLDS[player.styleRating]?.bonus || 1.0;
            score *= styleBonus;
            
            // Bonus por "Pura Ag√ºita"
            if (player.pureMode && player.impurity === 0) {
                score *= 1.5; // 50% bonus
            }
            
            return Math.floor(score);
        }

        // ============================================
        // FUNCIONES ORIGINALES DEL JUEGO BASE
        // ============================================
        
        function isOccupied(x, y) {
            if (x < 0 || x >= config.grid || y < 0 || y >= config.grid) return true;
            if (config.collision && obstacles.some(o => o.x === x && o.y === y)) return true;
            // Verificar tambi√©n contra secretos no descubiertos
            if (secrets.some(s => !s.discovered && s.x === x && s.y === y)) return true;
            return false;
        }

        function actualizarNPCs(onKick) {
            npcs.forEach(n => {
                const inZone = isInsideBlueZone(n.x, n.y);
                
                if(inZone) {
                    n.color = '#0ff'; n.char = '(*^œâ^*)';
                    if (onKick && Math.random() > 0.6) {
                        const d = [[1,0],[-1,0],[0,1],[0,-1]][Math.floor(Math.random()*4)];
                        const nx = n.x + d[0], ny = n.y + d[1];
                        if (!isNPCBlocked(nx, ny, n) && isInsideBlueZone(nx, ny)) {
                            n.x = nx; n.y = ny; n.dir = d[0] || n.dir;
                        }
                    }
                } else if(onKick && combo > 0) {
                    const dist = Math.sqrt(Math.pow(n.x-player.x,2)+Math.pow(n.y-player.y,2));
                    if (dist < config.followRadius) {
                        n.color='#ffa500'; n.char='(‚Ä¢_‚Ä¢)>';
                        let dx = n.x < player.x ? 1 : (n.x > player.x ? -1 : 0);
                        let dy = n.y < player.y ? 1 : (n.y > player.y ? -1 : 0);
                        if(!isNPCBlocked(n.x+dx, n.y+dy, n)) { 
                            n.x+=dx; n.y+=dy; n.dir=dx||n.dir; 
                        }
                    } else {
                        n.color='red'; n.char='(‡≤†_‡≤†)';
                    }
                } else { 
                    n.color='red'; n.char='(‡≤†_‡≤†)'; 
                }
            });
        }

        function isInsideBlueZone(x, y) {
            return (
                x >= blueZone.x &&
                x < blueZone.x + blueZone.w &&
                y >= blueZone.y &&
                y < blueZone.y + blueZone.h
            );
        }

        function actualizarDancers() {
            dancers.forEach(d => {
                d.moveCounter++;
                if (d.moveCounter >= 8) {
                    d.moveCounter = 0;
                    d.state = d.state === 0 ? 1 : 0;
                    
                    if (Math.random() < 0.3) {
                        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
                        const [dx, dy] = dirs[Math.floor(Math.random()*4)];
                        const nx = d.x + dx;
                        const ny = d.y + dy;
                        
                        if (!isOccupied(nx, ny)) {
                            d.x = nx;
                            d.y = ny;
                        }
                    }
                }
            });
        }

        function reiniciarEscena() {
            player = { 
                x: Math.floor(config.grid * 0.1), 
                y: Math.floor(config.grid * 0.1), 
                color: '#00ffff',
                dir: 1,
                hydration: 100,
                impurity: 0,
                lastMoveBeat: 0,
                comboStreak: 0,
                styleRating: 'S',
                pureMode: document.getElementById('check-pure-mode')?.checked || false,
                lastX: Math.floor(config.grid * 0.1),
                lastY: Math.floor(config.grid * 0.1)
            };
            
            npcs = []; 
            
            // Generar NPCs con estado "apagado"
            for(let i=0; i<config.npcCount; i++) {
                let x, y, attempts = 0;
                do { 
                    x = Math.floor(Math.random()*config.grid); 
                    y = Math.floor(Math.random()*config.grid); 
                    attempts++;
                } while((isOccupied(x, y) || isNPCOccupied(x, y, null)) && attempts < 100);
                if (attempts < 100) {
                    npcs.push({ 
                        x, y, 
                        color: '#666666',  // GRIS - Apagado
                        char: '(‡≤†_‡≤†)', 
                        dir: 1,
                        isIgnited: false,
                        ignitedAt: 0
                    });
                }
            }
            
            activePowerUpsOnMap = [];
            combo = 0;
            
            // Reiniciar estad√≠sticas
            playerStats = {
                npcsIgnited: 0,
                secretsFound: 0,
                maxCombo: 0,
                totalMoves: 0,
                perfectMoves: 0,
                timeInClub: 0,
                pureRun: player.pureMode
            };
            
            // Reiniciar secretos (mantener posiciones pero no descubiertos)
            secrets.forEach(s => s.discovered = false);
            
            // Reiniciar zonas VIP
            vipZones.forEach(v => v.entered = false);
            
            // Reiniciar dancers tambi√©n
            if (appearance.dancers) {
                dancers = [];
                for(let i = 0; i < 5; i++) {
                    let x, y;
                    do {
                        x = Math.floor(Math.random() * (config.grid-4)) + 2;
                        y = Math.floor(Math.random() * (config.grid-4)) + 2;
                    } while(isOccupied(x, y));
                    dancers.push({ x, y, state: 0, moveCounter: 0 });
                }
            }
            
            // Reinicializar sistema de interpolaci√≥n
            inicializarInterpolacion();
            
            // Actualizar HUD
            updateHydrationDisplay();
            document.getElementById('impurity-value').textContent = '0';
            const styleElement = document.querySelector('#style-rating');
            if (styleElement) styleElement.textContent = 'S';
            document.getElementById('combo-counter').innerText = '000';
        }



        function spawnPowerUps() {
            const now = Date.now();
            Object.keys(puConfig).forEach(id => {
                if (puConfig[id].enabled && (now - puConfig[id].last > puConfig[id].rate * 1000)) {
                    let x, y; do { x=Math.floor(Math.random()*config.grid); y=Math.floor(Math.random()*config.grid); } while(isOccupied(x,y));
                    activePowerUpsOnMap.push({ x, y, id });
                    puConfig[id].last = now;
                }
            });
        }

        function crearNota(isOffbeat, isDoubleTempo = false) {
            if(!isStarted) return;
            
            const el = document.createElement('div'); 
            el.className = 'note';
            
            // DDR CONFIGURACI√ìN - CARRIL √öNICO
            const laneHeight = 50;
            el.style.top = `${laneHeight}%`;
            
            // DDR - S√çMBOLOS MUSICALES Y EMOJIS
            if (isDoubleTempo) {
                el.style.border = "3px solid var(--excellent)";
                el.style.background = "rgba(0, 255, 255, 0.5)";
                el.textContent = '‚ö°';
                el.style.boxShadow = "0 0 10px rgba(0, 255, 255, 0.5)";
            } else if (isOffbeat) {
                el.style.border = "2px solid var(--excellent)";
                el.style.background = "rgba(33, 150, 243, 0.5)";
                el.textContent = '‚Ä¢';
                el.style.borderRadius = "50%";
                el.style.boxShadow = "0 0 8px rgba(33, 150, 243, 0.5)";
            } else {
                el.style.border = "2px solid #ffffff";
                el.style.background = "rgba(255, 82, 82, 0.6)";
                const symbols = ['‚ô™', '‚ô´', '‚ô¨', '‚ô©'];
                el.textContent = symbols[beatCounter % symbols.length];
                el.style.boxShadow = "0 0 8px rgba(255, 82, 82, 0.5)";
            }
            
            // DDR - EMOJIS PARA POWER-UPS ACTIVOS
            if (currentStatus?.type) {
                const powerupEmojis = {
                    'double_tempo': ['‚ö°', 'üöÄ', 'üí®'],
                    'invert_controls': ['üîÑ', '‚Ü™Ô∏è', '‚Ü©Ô∏è'],
                    'pause_beat': ['‚è∏Ô∏è', '‚è±Ô∏è', '‚è≥'],
                    'shake_screen': ['üå™Ô∏è', 'üåÄ', 'üí´'],
                    'tilt_screen': ['üìê', 'üìè', '‚öñÔ∏è'],
                    'invert_colors': ['üåà', 'üé®', 'üñºÔ∏è'],
                    'off_beat': ['üéµ', 'üé∂', 'üéº']
                };
                if (powerupEmojis[currentStatus.type]) {
                    const emojis = powerupEmojis[currentStatus.type];
                    el.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                }
            }
            
            // Tama√±o fijo para todas las notas DDR
            el.style.width = "30px";
            el.style.height = "30px";
            el.style.fontSize = "16px";
            el.style.fontWeight = "bold";
            el.style.display = "flex";
            el.style.alignItems = "center";
            el.style.justifyContent = "center";
            el.style.zIndex = "5";
            
            document.getElementById('zona-beat').appendChild(el);
            
            const obj = { el, isOffbeat, isDoubleTempo }; 
            activeNotes.push(obj);

            // DDR - VELOCIDAD MUY LENTA Y ESPACIADO ORDENADO
            const noteDuration = 2800;
            const noteWindow = config.noteWindow || 0.75;
            
            // DDR - POSICI√ìN INICIAL ORDENADA (CARRIL LINEAL)
            const basePosition = 450;
            const spacing = 35;
            const noteOffset = activeNotes.length * spacing;
            const startPosition = Math.min(basePosition + noteOffset, 650);
            
            el.style.left = `${startPosition}px`;
            
            const anim = el.animate([
                { left: `${startPosition}px`, opacity: 1 },
                { left: '30px', offset: noteWindow, opacity: 1 },
                { left: '-50px', opacity: 0 }
            ], {
                duration: noteDuration,
                easing: 'linear'
            });

            anim.onfinish = () => {
                // Si la nota llega al final y sigue en el array, el jugador no la puls√≥: ES UN MISS
                if(activeNotes.includes(obj)) { 
                    combo = 0; 
                    player.comboStreak = 0;
                    document.getElementById('combo-counter').innerText = "000";
                    document.getElementById('accuracy-feedback').innerText = "MISS";
                    document.getElementById('accuracy-feedback').style.color = "var(--miss)";
                    activeNotes.shift(); 
                }
                el.remove();
            };
        }

        function generarTrenInicialDDR() {
            if (!isStarted) return;
            
            console.log('[DDR] Generando tren inicial de 8 notas...');
            
            // Calcular espaciado basado en BPM actual
            const bpm = config?.bpm || 120;
            const msPerBeat = 60000 / bpm;
            
            // Generar 8 notas escalonadas
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    if (isStarted) {
                        const isOffbeat = (i % 3 === 2);
                        crearNota(isOffbeat, false);
                    }
                }, i * (msPerBeat / 1.5));
            }
        }

        function updateHUD() {
            // === NUEVOS SISTEMAS RPG ===
            if (isStarted) {
                // 1. Actualizar interpolaci√≥n
                actualizarRenderPositions();
                
                // 2. Actualizar sistema de rebote
                actualizarSistemaRebote();
                
                // 3. Aplicar screen shake RPG
                aplicarScreenShakeRPG();
                
                // 4. Activar vibraci√≥n RPG
                activarVibracionRPG();
            }
            
            // === SISTEMAS ORIGINALES ===
            // Actualizar hidrataci√≥n
            updateCyborgBiometrics();
            
            // Actualizar elementos decorativos
            updateStrobe();
            updateSmoke();
            
            // Aplicar screen shake seg√∫n configuraci√≥n original
            applyScreenShake();
            
            if (currentStatus.beats > 0) {
                currentStatus.beats--;
                document.getElementById('status-hud').style.display = 'flex';
                document.getElementById('status-label').innerText = `EFECTO: ${currentStatus.label}`;
                document.getElementById('progress-fill').style.width = (currentStatus.beats / currentStatus.maxBeats * 100) + "%";
                if (currentStatus.type === 'invert_colors' && beatCounter % 2 === 0) document.getElementById('game-container').classList.toggle('inverted');
                if (currentStatus.type === 'shake_screen') {
                    const i = 10; document.getElementById('game-container').style.transform = `translate(${(Math.random()-0.5)*i}px, ${(Math.random()-0.5)*i}px)`;
                }
                if (currentStatus.type === 'tilt_screen') { document.getElementById('game-container').style.transform = `rotate(${Math.sin(beatCounter)*5}deg)`; }
                
                // Manage double_tempo loop
                if (currentStatus.type === 'double_tempo' && !doubleTempoLoop.state) {
                    doubleTempoLoop.start(0);
                }
            } else {
                // Stop double_tempo loop when effect ends
                if (currentStatus.type === 'double_tempo' && doubleTempoLoop.state) {
                    doubleTempoLoop.stop();
                }
                currentStatus.type = null; document.getElementById('status-hud').style.display = 'none';
                document.getElementById('game-container').classList.remove('inverted');
                document.getElementById('game-container').style.transform = 'none';
            }
            document.getElementById('combo-counter').innerText = combo.toString().padStart(3, '0');
        }

        function autoAdjustBpm() {
            config.bpm = Math.min(Math.max(parseInt(config.bpm) + (Math.random() > 0.5 ? 5 : -5), 60), 220);
            Tone.Transport.bpm.rampTo(config.bpm, 1);
            document.getElementById('bpm-display').innerText = `BPM: ${Math.round(config.bpm)}`;
        }

        // ============================================
        // NUEVO: INICIALIZAR HUD CIBORG
        // ============================================
        
        function initCyborgHUD() {
            updateHydrationDisplay();
            document.getElementById('impurity-value').textContent = '0';
            const styleElement = document.querySelector('#style-rating');
            if (styleElement) styleElement.textContent = 'S';
            
            // Configurar modo "Pura Ag√ºita"
            const pureModeCheckbox = document.getElementById('check-pure-mode');
            if (pureModeCheckbox) {
                pureModeCheckbox.checked = false;
                pureModeCheckbox.onchange = function(e) {
                    player.pureMode = e.target.checked;
                    if (player.pureMode && player.impurity > 0) {
                        player.pureMode = false;
                        e.target.checked = false;
                        document.getElementById('accuracy-feedback').innerText = "IMPURE - CAN'T GO PURE";
                        document.getElementById('accuracy-feedback').style.color = "#ff4444";
                    } else if (enabled) {
                        document.getElementById('accuracy-feedback').innerText = "PURA AG√úITA MODE";
                        document.getElementById('accuracy-feedback').style.color = "#00ffff";
                    }
                };
            }
        }

        // ============================================
        // NUEVO: FUNCI√ìN DE INICIO DE JUEGO
        // ============================================
        
        function startGameSession() {
            isStarted = true; 
            document.getElementById('start-overlay').style.display = 'none';
            
            // Iniciar tren de notas
            setTimeout(generarTrenInicialDDR, 300);
            
            window.player = player; 
            window.npcs = npcs;
            window.isStarted = isStarted;
            
            console.log("üéÆ CYBORG CLUB 2777 - Sesi√≥n iniciada");
        }

        // ============================================
        // AUDIO ENGINE Y LOOPS
        // ============================================

        // Double tempo loop
        let doubleTempoNoteCounter = 0;
        const doubleTempoLoop = new Tone.Loop((time) => {
            if (!isStarted || currentStatus.type !== 'double_tempo') return;
            
            Tone.Draw.schedule(() => {
                const isOffbeat = (doubleTempoNoteCounter % 2 === 1);
                crearNota(isOffbeat, true);
                canMove = true;
                doubleTempoNoteCounter++;
            }, time);
        }, "8n");

        // Main game loop
        const loop = new Tone.Loop((time) => {
            const isPause = (currentStatus.type === 'pause_beat' && (beatCounter+1)%8 === 0);
            if (!isPause) {
                kick.triggerAttackRelease("C1", "8n", time);
                if (currentStatus.type === 'off_beat') {
                    Tone.Draw.schedule(() => crearNota(true), time + Tone.Time("8n").toSeconds());
                }
            }
            if (config.snareEnabled) snare.triggerAttackRelease("16n", time + Tone.Time("8n").toSeconds());

            Tone.Draw.schedule(() => {
                beatCounter++;
                
                // === NUEVO: ACTUALIZACIONES CYBORG ===
                if (isStarted) {
                    // 1. Biometr√≠a ciborg
                    updateCyborgBiometrics();
                    
                    // 2. Incrementar tiempo en club
                    playerStats.timeInClub++;
                    
                    // 3. Verificar colisiones e ignici√≥n
                    checkCyborgCollisions();
                }
                // === FIN NUEVO ===
                
                updateHUD();
                if (isStarted) spawnPowerUps();
                if (beatCounter % 16 === 0 && document.getElementById('playlist-auto-bpm').checked) autoAdjustBpm();
                djStep = (djStep + 1) % 2;
                actualizarNPCs(true);
                actualizarDancers();
                
                if (currentStatus.type !== 'double_tempo') {
                    crearNota(false);
                }
                
                if (activeNotes.length > 40) {
                    combo = 0;
                    player.comboStreak = 0;
                    document.getElementById('combo-counter').innerText = "000";
                    document.getElementById('accuracy-feedback').innerText = "OVERLOAD";
                    document.getElementById('accuracy-feedback').style.color = "var(--miss)";
                    activeNotes.forEach(note => note.el.remove());
                    activeNotes = [];
                }
                canMove = true;
                
            }, time);
        }, "4n");

        // ============================================
        // INPUT HANDLER CON SISTEMA RPG
        // ============================================
        
        window.addEventListener('keydown', (e) => {
            if(!isStarted || !canMove || activeNotes.length === 0) {
                return;
            }
            
            const n = activeNotes[0];
            const noteRect = n.el.getBoundingClientRect();
            const targetRect = document.getElementById('beat-target').getBoundingClientRect();
            const noteLeft = noteRect.left;
            const targetLeft = targetRect.left;
            const distance = Math.abs(noteLeft - targetLeft);
            const maxDistance = 60;
            
            if (distance > maxDistance) {
                combo = 0;
                player.comboStreak = 0;
                player.lastMoveBeat = beatCounter;
                document.getElementById('combo-counter').innerText = "000";
                document.getElementById('accuracy-feedback').innerText = "TIMING_ERROR";
                document.getElementById('accuracy-feedback').style.color = "var(--miss)";
                n.el.remove();
                activeNotes.shift();
                canMove = false;
                return;
            }
            
            let k = e.key;
            if(currentStatus.type === 'invert_controls') {
                const inv = { ArrowUp:'ArrowDown', ArrowDown:'ArrowUp', ArrowLeft:'ArrowRight', ArrowRight:'ArrowLeft' };
                k = inv[k] || k;
            }
            
            let nX = player.x, nY = player.y;
            let step = 1;
            if(k==='ArrowUp') nY-=step; 
            if(k==='ArrowDown') nY+=step; 
            if(k==='ArrowLeft') nX-=step; 
            if(k==='ArrowRight') nX+=step;
            
            // USAR SISTEMA DE COLISI√ìN CON REBOTE
            const colision = verificarColisionConRebote(nX, nY);
            
            if(!colision) { 
                player.x = nX; 
                player.y = nY; 
                player.lastMoveBeat = beatCounter;
                playerStats.totalMoves++;
                
                // VERIFICAR MOVIMIENTO PERFECTO
                const timingAccuracy = 1 - (distance / maxDistance);
                if (timingAccuracy > 0.9) {
                    playerStats.perfectMoves++;
                }
                
                const comboBefore = combo;
                combo++;
                player.comboStreak++;
                document.getElementById('combo-counter').innerText = combo.toString().padStart(3, '0');
                
                if (activeNotes[0] && activeNotes[0].el) {
                    const noteEl = activeNotes[0].el;
                    noteEl.classList.add('hit');
                    noteEl.style.background = 'rgba(0, 255, 0, 0.7)';
                    noteEl.style.boxShadow = '0 0 15px rgba(0, 255, 0, 0.5)';
                    
                    setTimeout(() => {
                        if (noteEl) {
                            noteEl.classList.remove('hit');
                        }
                    }, 150);
                }
                
                if (timingAccuracy > 0.9) {
                    document.getElementById('accuracy-feedback').innerText = "PERFECT!";
                    document.getElementById('accuracy-feedback').style.color = "var(--excellent)";
                } else if (timingAccuracy > 0.7) {
                    document.getElementById('accuracy-feedback').innerText = "GREAT!";
                    document.getElementById('accuracy-feedback').style.color = "var(--great)";
                } else {
                    document.getElementById('accuracy-feedback').innerText = "GOOD";
                    document.getElementById('accuracy-feedback').style.color = "var(--good)";
                }
                
                n.el.remove(); 
                activeNotes.shift(); 
                canMove = false;
                
                // Detecci√≥n de Power-Ups en el mapa
                const pIdx = activePowerUpsOnMap.findIndex(p => p.x === player.x && p.y === player.y);
                if(pIdx !== -1) {
                    const pu = activePowerUpsOnMap[pIdx];
                    
                    // Check for hydration and impurity
                    checkPowerUpForHydration(pu.id);
                    
                    if (currentStatus.type === 'double_tempo' && typeof doubleTempoLoop !== 'undefined' && doubleTempoLoop.state) {
                        doubleTempoLoop.stop();
                    }
                    
                    currentStatus = { 
                        type: puConfig[pu.id].effect, 
                        label: EFFECTS_LIST[puConfig[pu.id].effect], 
                        beats: puConfig[pu.id].dur, 
                        maxBeats: puConfig[pu.id].dur 
                    };
                    
                    if (currentStatus.type === 'double_tempo' && isStarted && typeof doubleTempoLoop !== 'undefined') {
                        doubleTempoLoop.start(0);
                    }
                    
                    activePowerUpsOnMap.splice(pIdx, 1);
                }
            } else {
                // Colisi√≥n con obst√°culo (manejada por sistema de rebote)
                // El combo NO se pierde gracias al sistema de rebote
                player.lastMoveBeat = beatCounter;
                
                // Solo feedback visual
                if (!reboteActivo) { // Si no hay rebote activo (colisi√≥n normal)
                    combo = Math.max(0, combo - 1);
                    player.comboStreak = 0;
                    document.getElementById('combo-counter').innerText = combo.toString().padStart(3, '0');
                    document.getElementById('accuracy-feedback').innerText = "COLISI√ìN";
                    document.getElementById('accuracy-feedback').style.color = "var(--miss)";
                }
            }
        });

        function checkPowerUpForHydration(powerUpId) {
            if (powerUpId === 'WATER') {
                player.hydration = Math.min(100, player.hydration + 30);
                
                document.getElementById('accuracy-feedback').innerText = "HYDRATED!";
                document.getElementById('accuracy-feedback').style.color = "#3333ff";
                
                // No incrementa impurezas
            } else if (PU_TYPES[powerUpId].impurity > 0) {
                // Chemical - incrementa impurezas
                player.impurity += PU_TYPES[powerUpId].impurity;
                
                // Si est√° en modo puro, se desactiva
                if (player.pureMode) {
                    player.pureMode = false;
                    document.getElementById('check-pure-mode').checked = false;
                    document.getElementById('accuracy-feedback').innerText = "PURE MODE LOST";
                    document.getElementById('accuracy-feedback').style.color = "#ff4444";
                }
                
                playerStats.pureRun = false;
            }
            
            // Actualizar display de impurezas
            document.getElementById('impurity-value').textContent = player.impurity;
            
            // Actualizar story state si existe
            if (window.STORY && window.STORY.active && window.STORY.step === 2) {
                window.STORY.state.hydrated = true;
            }
            
            // Actualizar display
            updateHydrationDisplay();
        }

        // ============================================
        // RENDER FUNCTION - ACTUALIZADA CON SISTEMA RPG
        // ============================================
        
        function draw() {
            const g = config.grid;
            const cw = 450/g, ch = 350/g;
            ctx.clearRect(0,0,450,350);
            ctx.fillStyle = "#000"; ctx.fillRect(0,0,450,350);
            
            // Aplicar efecto de strobe si est√° activo
            if (appearance.strobeLights && strobeFlash) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
                ctx.fillRect(0, 0, 450, 350);
            }

            // Grid y Corral
            ctx.fillStyle = "rgba(0, 150, 255, 0.4)";
            ctx.fillRect(blueZone.x*cw, blueZone.y*ch, blueZone.w*cw, blueZone.h*ch);
            
            // ============================================
            // DIBUJAR ELEMENTOS DECORATIVOS
            // ============================================
            
            // 1. L√çNEAS DE NE√ìN EN EL PISO
            if (appearance.neonFloor) {
                neonLines.forEach(line => {
                    ctx.strokeStyle = line.color;
                    ctx.lineWidth = line.width;
                    ctx.globalAlpha = 0.6 + 0.4 * Math.sin(Date.now() * 0.002);
                    
                    if (line.vertical) {
                        ctx.beginPath();
                        ctx.moveTo(line.x * cw, line.y1 * ch);
                        ctx.lineTo(line.x * cw, line.y2 * ch);
                        ctx.stroke();
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(line.x1 * cw, line.y * ch);
                        ctx.lineTo(line.x2 * cw, line.y * ch);
                        ctx.stroke();
                    }
                });
                ctx.globalAlpha = 1;
            }
            
            // 2. RAYOS L√ÅSER
            if (appearance.lasers) {
                laserBeams.forEach(laser => {
                    ctx.strokeStyle = laser.color;
                    ctx.lineWidth = laser.width;
                    const pulse = Math.sin(Date.now() * 0.001 + laser.pulse) * 0.3 + 0.7;
                    ctx.globalAlpha = pulse;
                    
                    if (laser.vertical) {
                        ctx.beginPath();
                        ctx.moveTo(laser.x * cw, laser.y1 * ch);
                        ctx.lineTo(laser.x * cw, laser.y2 * ch);
                        ctx.stroke();
                        
                        // Efecto de brillo
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = laser.color;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else {
                        ctx.beginPath();
                        ctx.moveTo(laser.x1 * cw, laser.y * ch);
                        ctx.lineTo(laser.x2 * cw, laser.y * ch);
                        ctx.stroke();
                        
                        // Efecto de brillo
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = laser.color;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                });
                ctx.globalAlpha = 1;
            }
            
            // 3. HUMO
            if (appearance.smokeMachine) {
                smokeParticles.forEach(p => {
                    ctx.fillStyle = `rgba(200, 200, 200, ${p.opacity})`;
                    ctx.beginPath();
                    ctx.arc(p.x * cw, p.y * ch, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
            }

            // Secretos (si no descubiertos)
            if (appearance.secrets) {
                secrets.forEach(secret => {
                    if (!secret.discovered) {
                        ctx.fillStyle = secret.color;
                        ctx.font = `${ch*0.6}px Courier`;
                        ctx.textAlign = "center";
                        ctx.fillText(secret.char, (secret.x+0.5)*cw, (secret.y+1)*ch);
                        
                        // Contorno sutil para secretos
                        ctx.strokeStyle = "#333333";
                        ctx.lineWidth = 1;
                        ctx.strokeRect(secret.x*cw+2, secret.y*ch+2, cw-4, ch-4);
                    } else {
                        // Secreto descubierto - brillar
                        ctx.fillStyle = "#00ffff";
                        ctx.font = `${ch*0.8}px Courier`;
                        ctx.textAlign = "center";
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "#00ffff";
                        ctx.fillText("‚òÖ", (secret.x+0.5)*cw, (secret.y+1)*ch);
                        ctx.shadowBlur = 0;
                    }
                });
            }
            
            // Zonas VIP
            if (appearance.vipZones) {
                vipZones.forEach(vip => {
                    ctx.fillStyle = vip.entered ? 
                        "rgba(255, 255, 0, 0.3)" : 
                        "rgba(255, 215, 0, 0.1)";
                    ctx.fillRect(vip.x*cw, vip.y*ch, vip.w*cw, vip.h*ch);
                    
                    // Contorno VIP
                    ctx.strokeStyle = vip.entered ? "#ffff00" : "#ffd700";
                    ctx.lineWidth = 1;
                    ctx.strokeRect(vip.x*cw, vip.y*ch, vip.w*cw, vip.h*ch);
                    
                    if (vip.entered) {
                        ctx.fillStyle = "#ffff00";
                        ctx.font = `${ch*0.6}px Courier`;
                        ctx.textAlign = "center";
                        ctx.fillText("VIP", (vip.x + vip.w/2)*cw, (vip.y + vip.h/2)*ch);
                    }
                });
            }

            // Power-Ups
            activePowerUpsOnMap.forEach(p => {
                const color = PU_TYPES[p.id].color;
                ctx.strokeStyle = color; ctx.strokeRect(p.x*cw+1, p.y*ch+1, cw-2, ch-2);
                ctx.fillStyle = color; ctx.font = `${ch*0.8}px Courier`; ctx.textAlign="center";
                ctx.fillText(PU_TYPES[p.id].char, (p.x+0.5)*cw, (p.y+0.8)*ch);
            });

            // Decoraci√≥n
            ctx.font = `${ch*0.8}px Courier`; ctx.textAlign="center";
            obstacles.forEach(o => {
                if(o.type === 'djTable') {
                    ctx.fillStyle = o.color;
                    ctx.shadowBlur = 5;
                    ctx.shadowColor = o.color;
                    ctx.fillText(o.char, (o.x+0.5)*cw, (o.y+1)*ch);
                    if (beatCounter % 2 === 0) {
                        ctx.fillStyle = '#ff00ff';
                        ctx.fillText('‚óè', (o.x+0.5)*cw, (o.y+0.5)*ch);
                    }
                    ctx.shadowBlur = 0;
                } else if(o.type === 'barCounter') {
                    ctx.fillStyle = o.color;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = o.color;
                    ctx.fillText(o.char, (o.x+0.5)*cw, (o.y+1)*ch);
                    ctx.shadowBlur = 0;
                } else if(o.type === 'speaker') {
                    // Los speakers se dibujan arriba con animaci√≥n
                } else { 
                    ctx.fillStyle=o.color; 
                    ctx.fillText(o.char, (o.x+0.5)*cw, (o.y+1)*ch); 
                }
            });

            // ============================================
            // SISTEMA DE DIBUJADO DE PERSONAJES (CON INTERPOLACI√ìN)
            // ============================================
            
            function drawThreePartCharacter(x, y, skin, dir = 1, entidad = null) {
                if (!skin) return; 
                
                // Usar posici√≥n interpolada si est√° habilitado
                let drawX = x;
                let drawY = y;
                
                if (interpolacionHabilitada && entidad === player) {
                    drawX = renderData.player.renderX;
                    drawY = renderData.player.renderY;
                } else if (interpolacionHabilitada && entidad && npcs.includes(entidad)) {
                    const npcIndex = npcs.indexOf(entidad);
                    if (renderData.npcs.has(npcIndex)) {
                        const npcRender = renderData.npcs.get(npcIndex);
                        drawX = npcRender.renderX;
                        drawY = npcRender.renderY;
                    }
                }
                
                const centerX = (drawX + 0.5) * cw;
                const baseLineY = (drawY + 1) * ch;
                
                ctx.save();
                
                // --- L√ìGICA DE COLOR ---
                if (config.npcColorMode === 'Rave_Alternating') {
                    const luces = ['#00ff00', '#00ffff', '#ff00ff', '#ffff00'];
                    ctx.fillStyle = luces[beatCounter % luces.length];
                } else if (config.npcColorMode === 'Dark_Mode') {
                    ctx.fillStyle = '#222222';
                } else {
                    // MODO: Cyborg_Standard -> Prioridad a la entidad
                    if (entidad && entidad.color) {
                        ctx.fillStyle = entidad.color;
                    } else if (entidad === player) {
                        ctx.fillStyle = "#00ff41";
                    } else if (entidad && entidad.type === 'dj') {
                        ctx.fillStyle = "#00ffff";
                    } else {
                        ctx.fillStyle = "#ffffff";
                    }
                }

                // --- SUPER STRETCH 1.45x ---
                ctx.translate(centerX, baseLineY);
                ctx.scale(dir, 1.45); 
                
                const fontSize = Math.floor(ch * 0.72); 
                ctx.font = `${fontSize}px ${getComputedStyle(document.body).fontFamily}`;
                ctx.textAlign = 'center';

                // Dibujo de las 3 partes
                if (skin.head) ctx.fillText(skin.head, 0, -ch * 1.05);
                if (skin.torso) ctx.fillText(skin.torso, 0, -ch * 0.55); 
                if (skin.legs) ctx.fillText(skin.legs, 0, -ch * 0.05);
                
                ctx.restore();
                ctx.font = `${ch}px ${getComputedStyle(document.body).fontFamily}`;
            }

            // NPCs
            npcs.forEach(n => {
                let skin = n.isIgnited ? SKINS.npc_ignited : SKINS.npc_inactive;
                drawThreePartCharacter(n.x, n.y, skin, n.dir || 1, n);
            });

            // Player
            const pSkin = appearance.playerGlow ? SKINS.npc_ignited : SKINS.npc_inactive;
            drawThreePartCharacter(player.x, player.y, pSkin, player.dir || 1, player);

            // Avatar override visual
            let playerSkin;
            switch (appearance.avatar) {
                case '(^o^)': playerSkin = { head: '(^o^)', torso: ' || ', legs: '/ \\' }; break;
                case '(‚óï‚Äø‚óï)': playerSkin = { head: '(‚óï‚Äø‚óï)', torso: ' || ', legs: '/ \\' }; break;
                case 'd(-_-)b': playerSkin = { head: 'd(-_-)b', torso: ' || ', legs: '/ \\' }; break;
                default: playerSkin = { head: '(‚åê‚ñ†_‚ñ†)', torso: ' || ', legs: '/ \\' };
            }
            drawThreePartCharacter(player.x, player.y, playerSkin, player.dir || 1, player);

            // Dancers
            dancers.forEach(d => {
                const skin = d.state === 0 ? SKINS.dancer_state0 : SKINS.dancer_state1;
                drawThreePartCharacter(d.x, d.y, skin, d.dir || 1, d);
            });

            // Bartender
            if (appearance.barman) {
                const bartenderPos = obstacles.find(o => o.char === '(‡≤†_‡≤†)Êó¶');
                if (bartenderPos) {
                    drawThreePartCharacter(bartenderPos.x, bartenderPos.y, SKINS.bartender, bartenderPos.dir || 1, bartenderPos);
                }
            }

            // DJ
            if (appearance.dj) {
                const djPos = obstacles.find(o => o.type === 'dj');
                if (djPos) {
                    const skin = djStep === 0 ? SKINS.dj_state0 : SKINS.dj_state1;
                    drawThreePartCharacter(djPos.x, djPos.y, skin, djPos.dir || 1, djPos);
                }
            }

            requestAnimationFrame(draw);
        }

        // ============================================
        // BINDINGS Y CONFIGURACI√ìN
        // ============================================
        
        const bind = (id, target, prop, callback) => {
            const el = document.getElementById(id);
            if (!el) {
                console.warn(`‚ö†Ô∏è Parche: El elemento ID "${id}" no existe en el HTML.`);
                return;
            }
            if(el.type === 'checkbox') el.onchange = (e) => { 
                if (target && prop) target[prop] = e.target.checked;
                if(callback) callback(e); 
            };
            else el.oninput = (e) => { 
                if (target && prop) target[prop] = parseFloat(e.target.value); 
                if(callback) callback(e); 
            };
        };
        
        // Bindings existentes...
        bind('input-grid', config, 'grid', () => { 
            if (mapaTipo === 'estructural') {
                generarMapaEstructural(config.grid);
            } else if (mapaTipo === 'hibrido') {
                generarMapaHibrido(config.grid);
            } else {
                generarLayoutProcedural();
            }
            reiniciarEscena(); 
        });
        bind('input-npc', config, 'npcCount', reiniciarEscena);
        bind('input-bpm', config, 'bpm', () => Tone.Transport.bpm.value = config.bpm);
        
        // Nuevos bindings para Cyborg Club
        bind('input-ignition-radius', config, 'ignitionRadius');
        bind('input-hydration-decay', config, 'hydrationDecay');
        bind('input-combo-decay', config, 'comboDecayRate');
        bind('input-wall-density', config, 'wallDensity', () => {
            config.proceduralGen = true;
            generarLayoutProcedural();
        });
        
        bind('check-procedural', config, 'proceduralGen', (e) => {
            if (e.target.checked) {
                config.proceduralGen = true;
                generarLayoutProcedural();
            } else {
                config.proceduralGen = false;
                generarLayoutClasico(config.grid);
            }
            reiniciarEscena();
        });
        
        bind('check-secrets', appearance, 'secrets', () => {
            if (!appearance.secrets) {
                secrets = [];
            } else if (config.proceduralGen) {
                generarLayoutProcedural();
            }
        });
        
        bind('check-vip', appearance, 'vipZones', () => {
            if (!appearance.vipZones) {
                vipZones = [];
            } else if (config.proceduralGen) {
                generarLayoutProcedural();
            }
        });
        
        bind('check-glitch', appearance, 'glitchEffects');
        bind('check-elastic', config, 'elasticCollisions');
        bind('check-collision-elastic', config, 'elasticCollisions');
        
        // Funci√≥n para toggle de modo puro
        function togglePureMode(enabled) {
            player.pureMode = enabled;
            if (enabled && player.impurity > 0) {
                player.pureMode = false;
                document.getElementById('check-pure-mode').checked = false;
                document.getElementById('accuracy-feedback').innerText = "IMPURE - CAN'T GO PURE";
                document.getElementById('accuracy-feedback').style.color = "#ff4444";
            } else if (enabled) {
                document.getElementById('accuracy-feedback').innerText = "PURA AG√úITA MODE";
                document.getElementById('accuracy-feedback').style.color = "#00ffff";
            }
        }
        
        document.getElementById('start-btn').onclick = async () => {
            await Tone.start();
            
            const initialKickVol = parseFloat(document.getElementById('input-kick-volume').value);
            const initialSnareVol = parseFloat(document.getElementById('input-snare-volume').value);
            
            kickVolume = new Tone.Volume(initialKickVol).toDestination();
            snareVolume = new Tone.Volume(initialSnareVol).toDestination();
            
            kick = new Tone.MembraneSynth().connect(kickVolume);
            snare = new Tone.NoiseSynth({ envelope: { decay: 0.1 } }).connect(snareVolume);
            
            updateKickParams();
            Tone.Transport.bpm.value = config.bpm;
            Tone.Transport.start(); 
            loop.start(0);
            
            startGameSession();
        };

        document.getElementById('btn-generate-club').onclick = () => {
            if (mapaTipo === 'estructural') {
                generarMapaEstructural(config.grid);
            } else if (mapaTipo === 'hibrido') {
                generarMapaHibrido(config.grid);
            } else {
                generarLayoutProcedural();
            }
            reiniciarEscena();
            document.getElementById('accuracy-feedback').innerText = "CLUB REGENERATED";
            document.getElementById('accuracy-feedback').style.color = "#00ffff";
        };

        document.getElementById('btn-random-pu').onclick = () => {
            Object.keys(puConfig).forEach(k => puConfig[k].enabled = Math.random() > 0.4);
            renderPreGameMenu();
        };

        // Controles de volumen individuales para kick y snare
        document.getElementById('input-kick-volume').oninput = (e) => {
            if (kickVolume) kickVolume.volume.value = e.target.value;
        };
        document.getElementById('input-snare-volume').oninput = (e) => {
            if (snareVolume) snareVolume.volume.value = e.target.value;
        };

        const setupPanel = (btn, panel) => {
            document.getElementById(btn).onclick = () => document.getElementById(panel).style.display = 'flex';
            document.getElementById('close-'+panel.split('-')[0]).onclick = () => document.getElementById(panel).style.display = 'none';
        };
        setupPanel('open-appearance', 'appearance-panel');
        setupPanel('open-playlist', 'playlist-panel');
        setupPanel('open-powerups', 'powerup-panel');
        setupPanel('open-debug', 'debug-panel');

        document.getElementById('input-volume').oninput = (e) => Tone.Destination.volume.value = e.target.value;
        
        document.getElementById('user-avatar').onchange = (e) => appearance.avatar = e.target.value;

        // ============================================
        // CONTROLES M√ìVILES
        // ============================================
        
        function initMobileControls() {
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isSmallScreen = window.innerWidth < 768;
            
            if (isMobile || isSmallScreen) {
                document.getElementById('mobile-toggle-btn').style.display = 'block';
                adjustScaleForMobile();
            }
            
            const mobileToggleBtn = document.getElementById('mobile-toggle-btn');
            mobileToggleBtn.addEventListener('click', toggleMobileMode);
            
            setupTouchControls();
            window.addEventListener('resize', handleResize);
            
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
            document.addEventListener('mozfullscreenchange', handleFullscreenChange);
            document.addEventListener('MSFullscreenChange', handleFullscreenChange);
        }
        
        function adjustScaleForMobile() {
            const mainView = document.getElementById('main-view');
            const screenWidth = window.innerWidth;
            
            let scale = 1;
            if (screenWidth < 500) {
                scale = screenWidth / 500;
            }
            
            scale = Math.max(scale, 0.7);
            
            mainView.style.transform = `scale(${scale})`;
            mainView.style.transformOrigin = 'top center';
        }
        
        function toggleMobileMode() {
            const mobileToggleBtn = document.getElementById('mobile-toggle-btn');
            const touchPanel = document.getElementById('touch-controls-panel');
            
            isMobileMode = !isMobileMode;
            
            if (isMobileMode) {
                mobileToggleBtn.textContent = 'üì± SALIR M√ìVIL';
                mobileToggleBtn.classList.add('active');
                touchPanel.style.display = 'block';
                enterFullscreen();
                
                document.querySelectorAll('.menu-toggle').forEach(btn => {
                    btn.style.display = 'none';
                });
                
                document.getElementById('volume-control').style.display = 'none';
                document.getElementById('bpm-display').style.display = 'none';
                
            } else {
                mobileToggleBtn.textContent = 'üì± MODO M√ìVIL';
                mobileToggleBtn.classList.remove('active');
                touchPanel.style.display = 'none';
                exitFullscreen();
                
                document.querySelectorAll('.menu-toggle').forEach(btn => {
                    btn.style.display = 'block';
                });
                
                document.getElementById('volume-control').style.display = 'flex';
                document.getElementById('bpm-display').style.display = 'block';
            }
        }
        
        function setupTouchControls() {
            const touchButtons = document.querySelectorAll('.touch-btn');
            
            touchButtons.forEach(btn => {
                btn.addEventListener('touchstart', handleTouchStart, { passive: true });
                btn.addEventListener('touchend', handleTouchEnd, { passive: true });
                btn.addEventListener('mousedown', handleMouseDown);
                btn.addEventListener('mouseup', handleMouseUp);
                btn.addEventListener('mouseleave', handleMouseUp);
            });
        }
        
        function handleTouchStart(e) {
            e.preventDefault();
            const btn = e.target.closest('.touch-btn');
            if (!btn) return;
            
            const direction = btn.classList[1];
            simulateKeyPress(direction);
            btn.classList.add('active');
        }
        
        function handleTouchEnd(e) {
            e.preventDefault();
            const btn = e.target.closest('.touch-btn');
            if (!btn) return;
            
            btn.classList.remove('active');
        }
        
        function handleMouseDown(e) {
            const btn = e.target.closest('.touch-btn');
            if (!btn) return;
            
            const direction = btn.classList[1];
            simulateKeyPress(direction);
            btn.classList.add('active');
        }
        
        function handleMouseUp(e) {
            const btn = e.target.closest('.touch-btn');
            if (!btn) return;
            
            btn.classList.remove('active');
        }
        
        function simulateKeyPress(direction) {
            if (!isStarted || !canMove) return;
            
            const keyMap = {
                'touch-up': 'ArrowUp',
                'touch-down': 'ArrowDown',
                'touch-left': 'ArrowLeft',
                'touch-right': 'ArrowRight'
            };
            
            const key = keyMap[direction];
            if (!key) return;
            
            const event = new KeyboardEvent('keydown', {
                key: key,
                keyCode: key === 'ArrowUp' ? 38 : 
                         key === 'ArrowDown' ? 40 : 
                         key === 'ArrowLeft' ? 37 : 39,
                bubbles: true,
                cancelable: true
            });
            
            window.dispatchEvent(event);
        }
        
        function enterFullscreen() {
            const element = document.documentElement;
            
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.mozRequestFullScreen) {
                element.mozRequestFullScreen();
            } else if (element.webkitRequestFullscreen) {
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) {
                element.msRequestFullscreen();
            }
            
            isFullscreen = true;
        }
        
        function exitFullscreen() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.mozCancelFullScreen) {
                document.mozCancelFullScreen();
            } else if (document.webkitExitFullscreen) {
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) {
                document.msExitFullscreen();
            }
            
            isFullscreen = false;
        }
        
        function handleResize() {
            if (window.innerWidth < 768) {
                adjustScaleForMobile();
            } else {
                document.getElementById('main-view').style.transform = 'scale(1)';
            }
        }
        
        function handleFullscreenChange() {
            isFullscreen = !!(document.fullscreenElement || 
                            document.webkitFullscreenElement || 
                            document.mozFullScreenElement || 
                            document.msFullscreenElement);
            
            if (isFullscreen) {
                document.getElementById('main-view').style.transform = 'scale(1)';
            } else if (window.innerWidth < 768) {
                adjustScaleForMobile();
            }
        }
        
        // BLOQUEAR ZOOM EN M√ìVILES
        document.addEventListener('touchstart', function(e) {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        // ============================================
        // EXPOSICI√ìN DE VARIABLES PARA EL PARCHE
        // ============================================
        
        window.player = player;
        window.npcs = npcs;
        window.obstacles = obstacles;
        window.dancers = dancers;
        window.blueZone = blueZone;
        window.powerUps = activePowerUpsOnMap;
        window.playerHydration = player.hydration;
        window.playerStats = playerStats;
        window.secrets = secrets;
        window.vipZones = vipZones;
        window.config = config;
        window.appearance = appearance;
        window.isStarted = isStarted;
        
        // Exponer sistemas RPG
        window.renderData = renderData;
        window.cameraConfig = cameraConfig;
        window.shakeConfig = shakeConfig;
        window.vibrationConfig = vibrationConfig;
        
        console.log("‚ö° CYBORG CLUB 2777 - Sistema completo inicializado (Modo RPG/Dungeon Dance Activado)");

        function updateKickParams() {
            if (!kick) return;
            if (config.kickType === 'deep') {
                kick.set({ pitchDecay: 0.08, octaves: 5 });
            } else if (config.kickType === 'tight') {
                kick.set({ pitchDecay: 0.02, octaves: 2 });
            } else {
                kick.set({ pitchDecay: 0.1, octaves: 10 });
            }
        };

        function isNPCOccupied(x, y, selfNpc) {
            return npcs.some(n => n !== selfNpc && n.x === x && n.y === y);
        };

        function renderPreGameMenu() {
            const container = document.getElementById('pre-game-pu-list');
            if (!container) return;
            container.innerHTML = "";
            Object.keys(PU_TYPES).forEach(id => {
                const div = document.createElement('div');
                div.innerHTML = `<label style="color:${PU_TYPES[id].color}">
                    <input type="checkbox" id="pre-${id}" ${puConfig[id].enabled ? 'checked' : ''}> 
                    ${PU_TYPES[id].char} ${id}
                </label>`;
                container.appendChild(div);
                
                const checkbox = document.getElementById(`pre-${id}`);
                if (checkbox) {
                    checkbox.onchange = (e) => puConfig[id].enabled = e.target.checked;
                }
            });
        };

        /**
         * Comprueba si una posici√≥n est√° ocupada por OTRO NPC.
         * Evita que los personajes se encimen.
         */
        function isNPCOccupied(x, y, selfNpc) {
            return npcs.some(n => n !== selfNpc && n.x === x && n.y === y);
        }

        /**
         * Funci√≥n cr√≠tica: Comprueba si un NPC tiene el paso bloqueado.
         * Verifica l√≠mites del mapa, obst√°culos (paredes) y otros NPCs.
         */
        function isNPCBlocked(x, y, selfNpc) {
            // 1. Verificar si hay obst√°culos o fuera de l√≠mites (usando la funci√≥n isOccupied existente)
            if (isOccupied(x, y)) return true; 
            
            // 2. Verificar si la celda ya tiene un NPC
            if (isNPCOccupied(x, y, selfNpc)) return true;
            
            return false;
        };

        /**
         * PATCH 01: INDUSTRIAL CORE - SECTOR 7
         * Inyecta un escenario predefinido estilo RPG con etiquetas de zona.
         */
        function activarParcheSector7() {
            console.log("üõ†Ô∏è Inyectando arquitectura Industrial...");

            // 1. Forzar par√°metros de dise√±o
            config.grid = 64; 
            config.proceduralGen = false; // Desactivamos generaci√≥n aleatoria
            config.wallDensity = 0;
            
            // Usar colores predefinidos seg√∫n instrucciones
            appearance.playerColor = "#00ffff"; // CIAN
            appearance.npcActive = "#ff00ff";   // MAGENTA

            // 2. Definici√≥n de Zonas (Labels)
            const CLUB_ZONES = [
                { label: "[ PISTA CENTRAL ]", x: 26, y: 26, w: 12, h: 12 },
                { label: "[ BARRA NORTE ]",   x: 4,  y: 4,  w: 10, h: 6  },
                { label: "[ BARRA SUR ]",     x: 50, y: 54, w: 10, h: 6  },
                { label: "[ SERVICIOS ]",    x: 4,  y: 54, w: 8,  h: 8  },
                { label: "[ CABINA DJ ]",     x: 55, y: 28, w: 5,  h: 8  }
            ];

            // 3. Construcci√≥n de Obst√°culos (Mec√°nica RPG)
            obstacles = [];
            const addWall = (x, y, w, h) => {
                for(let i=x; i<x+w; i++) {
                    for(let j=y; j<y+h; j++) {
                        obstacles.push({x: i, y: j});
                    }
                }
            };

            // Crear layout de muros estructurales
            addWall(20, 0, 2, 25);   // Muro Oeste
            addWall(20, 39, 2, 25);  // Muro Oeste inferior
            addWall(42, 0, 2, 64);   // Muro Este divisor
            addWall(0, 20, 20, 2);   // Techo Sala Norte
            addWall(0, 44, 20, 2);   // Suelo Sala Sur

            // 4. Inyectar etiquetas en el renderizado
            // Guardamos la funci√≥n original para no perder el renderizado de NPCs/Jugador
            const coreRender = window.render; 
            window.render = function() {
                if (typeof coreRender === "function") coreRender();

                const cellSize = canvas.width / config.grid;
                ctx.save();
                ctx.font = "bold 9px 'Courier New'";
                
                CLUB_ZONES.forEach(zone => {
                    // Marco de zona tenue
                    ctx.strokeStyle = "rgba(255, 0, 255, 0.15)";
                    ctx.strokeRect(zone.x * cellSize, zone.y * cellSize, zone.w * cellSize, zone.h * cellSize);

                    // Etiqueta en Cian
                    ctx.fillStyle = "rgba(0, 255, 255, 0.5)";
                    ctx.fillText(zone.label, zone.x * cellSize + 2, zone.y * cellSize + 10);
                });
                ctx.restore();
            };

            // 5. Reiniciar sistema con el nuevo mapa
            player.x = 32; 
            player.y = 32; 
            reiniciarEscena(); 
            
            // Notificaci√≥n en el HUD de sistema
            const feedback = document.getElementById('accuracy-feedback');
            if(feedback) feedback.innerText = "PATCH_INSTALLED: SECTOR_7_ACTIVE";
        }

    </script>


<script>
(function() {
    console.log("üì° Sincronizando subsistema de luz...");

    // 1. Configuraci√≥n de par√°metros (Colores Reales)
    const laserSettings = {
        sources: 1,
        beams: 5,
        type: 'swing',
        color: 'rainbow', // CIAN PREDEFINIDO
        intensity: 0.1,
        active: true
    };

    // 2. Crear los controles en el panel de Apariencia
    const setupUI = () => {
        const panel = document.getElementById('appearance-panel');
        if (!panel) return;
        
        const div = document.createElement('div');
        div.innerHTML = `
            <div style="border: 1px solid var(--player-color); padding: 8px; margin-top: 10px; background: rgba(0,255,255,0.05)">
                <span style="color:var(--player-color); font-size:11px;">[LASER_ARRAY_V3]</span>
                <br>
                <label>FUENTES (1-20)</label>
                <input type="range" id="l-src" min="1" max="20" value="${laserSettings.sources}" style="width:100%">
                <label>HACES (1-15)</label>
                <input type="range" id="l-bem" min="1" max="15" value="${laserSettings.beams}" style="width:100%">
                <label>TIPO</label>
                <select id="l-typ" style="width:100%; background:#000; color:#00ffff; border:1px solid #333">
                    <option value="swing">SWING (P√âNDULO)</option>
                    <option value="pulse">PULSE (RADIAL)</option>
                    <option value="random">GLITCH (V5)</option>
                </select>
                <label>COLOR</label>
                <select id="l-col" style="width:100%; background:#000; color:#00ffff; border:1px solid #333">
                    <option value="#00ffff">CIAN (PLAYER)</option>
                    <option value="#ff00ff">MAGENTA (COMBO)</option>
                    <option value="rainbow">RAINBOW_V5</option>
                </select>
            </div>
        `;
        panel.appendChild(div);

        document.getElementById('l-src').oninput = (e) => laserSettings.sources = parseInt(e.target.value);
        document.getElementById('l-bem').oninput = (e) => laserSettings.beams = parseInt(e.target.value);
        document.getElementById('l-typ').onchange = (e) => laserSettings.type = e.target.value;
        document.getElementById('l-col').onchange = (e) => laserSettings.color = e.target.value;
    };

    // 3. FUNCI√ìN MAESTRA DE DIBUJO
    const renderLasers = () => {
        // Solo dibujar si el juego ha empezado y la opci√≥n general de l√°seres est√° en ON
        if (!isStarted || (typeof appearance !== 'undefined' && !appearance.lasers)) return;

        const time = Date.now() * 0.002;
        ctx.save();
        
        // Efecto de brillo (Glow)
        ctx.shadowBlur = 15;
        ctx.globalAlpha = laserSettings.intensity;
        ctx.lineWidth = 2;

        const spacing = canvas.width / (laserSettings.sources + 1);

        for (let s = 1; s <= laserSettings.sources; s++) {
            const xSource = s * spacing;
            const ySource = 40; // Detr√°s del DJ

            for (let i = 0; i < laserSettings.beams; i++) {
                ctx.beginPath();
                
                // L√≥gica de color
                if (laserSettings.color === 'rainbow') {
                    ctx.strokeStyle = `hsl(${(time * 50 + i * 20) % 360}, 100%, 50%)`;
                    ctx.shadowColor = ctx.strokeStyle;
                } else {
                    ctx.strokeStyle = laserSettings.color;
                    ctx.shadowColor = laserSettings.color;
                }

                ctx.moveTo(xSource, ySource);

                let targetX;
                if (laserSettings.type === 'swing') {
                    targetX = xSource + Math.sin(time + s) * 200 + (i * 15 - 30);
                } else if (laserSettings.type === 'pulse') {
                    targetX = xSource + (i - laserSettings.beams/2) * (Math.sin(time) * 100);
                } else {
                    targetX = Math.random() * canvas.width;
                }

                ctx.lineTo(targetX, canvas.height);
                ctx.stroke();
            }
        }
        ctx.restore();
    };

    // 4. INYECCI√ìN FORZADA EN EL LOOP
    // En lugar de sobreescribir render, nos "colamos" en el draw principal
    const originalRequestAnimationFrame = window.requestAnimationFrame;
    window.requestAnimationFrame = function(callback) {
        const newCallback = function(timestamp) {
            // Llamamos a los l√°seres justo antes de que el navegador pinte el frame
            // pero despu√©s de la l√≥gica del juego.
            callback(timestamp); 
            renderLasers();
        };
        return originalRequestAnimationFrame(newCallback);
    };

    setTimeout(setupUI, 600);
    console.log("‚úÖ Sistema de L√°seres V3 (Superior) Inyectado.");
})();


/**
 * PATCH 0.2: INDUSTRIAL CORE - SECTOR 7 (ENHANCED)
 * Incluye: DJ Animado, Barra con Items y Colores Mejorados.
 */
function activarParcheSector7() {
    console.log("üõ†Ô∏è Inyectando arquitectura Industrial Mejorada...");

    // 1. Configuraci√≥n de Escenario y Colores Predefinidos
    config.grid = 64; 
    config.proceduralGen = false;
    config.wallDensity = 0;
    appearance.playerColor = "#00ffff"; // CIAN
    appearance.npcActive = "#ff00ff";   // MAGENTA

    // Objetos globales para el parche (DJ y Barra)
    window.patchData = {
        djX: 57,
        djOffset: 0,
        djDir: 1,
        items: [] // Para almacenar tragos y agua
    };

    // 2. Definici√≥n de Zonas con Colores Mejorados
    const CLUB_ZONES = [
        { label: "[ PISTA CENTRAL ]", x: 26, y: 26, w: 12, h: 12, fill: "rgba(0, 255, 255, 0.05)" },
        { label: "[ BARRA NORTE ]",   x: 4,  y: 4,  w: 10, h: 6,  fill: "rgba(255, 0, 255, 0.1)" },
        { label: "[ BARRA SUR ]",     x: 50, y: 54, w: 10, h: 6,  fill: "rgba(255, 0, 255, 0.1)" },
        { label: "[ SERVICIOS ]",    x: 4,  y: 54, w: 8,  h: 8,  fill: "rgba(100, 100, 100, 0.1)" },
        { label: "[ CABINA DJ ]",     x: 55, y: 28, w: 5,  h: 8,  fill: "rgba(0, 255, 255, 0.1)" }
    ];

    // 3. Construcci√≥n de Obst√°culos
    obstacles = [];
    const addWall = (x, y, w, h) => {
        for(let i=x; i<x+w; i++) for(let j=y; j<y+h; j++) obstacles.push({x: i, y: j});
    };

    addWall(20, 0, 2, 25);   addWall(20, 39, 2, 25);
    addWall(42, 0, 2, 64);   addWall(0, 20, 20, 2);
    addWall(0, 44, 20, 2);
    addWall(4, 9, 10, 1);    // Mostrador Barra Norte
    addWall(50, 53, 10, 1);  // Mostrador Barra Sur

    // 4. Inyectar L√≥gica y Renderizado
    const coreRender = window.render; 
    window.render = function() {
        // --- L√ìGICA DE MOVIMIENTO DJ ---
        window.patchData.djOffset += 0.05 * window.patchData.djDir;
        if (Math.abs(window.patchData.djOffset) > 1.2) window.patchData.djDir *= -1;

        // --- SPAWN DE TRAGOS (Cada 64 pulsos) ---
        if (beatCounter % 64 === 0 && window.patchData.items.length < 6) {
            const isNorth = Math.random() > 0.5;
            window.patchData.items.push({
                x: isNorth ? 5 + Math.floor(Math.random()*8) : 51 + Math.floor(Math.random()*8),
                y: isNorth ? 8 : 52,
                type: Math.random() > 0.4 ? "üçπ" : "üíß" // 40% probabilidad de Agua
            });
        }

        // Renderizado original
        if (typeof coreRender === "function") coreRender();

        const cellSize = canvas.width / config.grid;
        ctx.save();
        
        // Dibujar Zonas
        CLUB_ZONES.forEach(zone => {
            ctx.fillStyle = zone.fill;
            ctx.fillRect(zone.x * cellSize, zone.y * cellSize, zone.w * cellSize, zone.h * cellSize);
            ctx.strokeStyle = "rgba(255, 0, 255, 0.3)";
            ctx.strokeRect(zone.x * cellSize, zone.y * cellSize, zone.w * cellSize, zone.h * cellSize);
            ctx.fillStyle = "#00ffff";
            ctx.font = "bold 9px 'Courier New'";
            ctx.fillText(zone.label, zone.x * cellSize + 2, zone.y * cellSize + 10);
        });

        // --- RENDER DJ CON MOVIMIENTO ---
        ctx.fillStyle = "#ff00ff"; // DJ en Magenta
        ctx.font = "12px Arial";
        ctx.fillText("üéß", (window.patchData.djX + window.patchData.djOffset) * cellSize, 32 * cellSize);

        // --- RENDER ITEMS Y COLISI√ìN ---
        window.patchData.items.forEach((item, index) => {
            ctx.fillText(item.type, item.x * cellSize, item.y * cellSize + 10);
            
            // Colisi√≥n con jugador (SISTEMA ACTUALIZADO)
            if (player.x === item.x && player.y === item.y) {
                if (item.type === "üíß") {
                    player.hydration = Math.min(100, (player.hydration || 0) + 30);
                    player.glowColor = "#00ffff"; // Feedback visual celeste inmediato
                }
                window.patchData.items.splice(index, 1);                console.log("Item recolectado: " + item.type);
            }
        });

        ctx.restore();
    };

    // 5. Reiniciar sistema
    player.x = 32; player.y = 32;
    reiniciarEscena();
    
    const feedback = document.getElementById('accuracy-feedback');
    if(feedback) feedback.innerText = "PATCH_v2: DJ_ANIMATED & BAR_STOCKS_LOADED";
}

/**
 * GENERADOR DE LAYOUT ESTRUCTURADO (PROVENIENTE DE V2)
 * Crea zonas l√≥gicas: Dancefloor, Bar, VIP y Staff.
 */
function generarLayoutEstructurado() {
    // Definir el tipo de mapa en la configuraci√≥n
    config.mapaTipo = 'estructurado';
    
    // Reiniciar el grid (vac√≠o)
    grid = Array(config.gridSize).fill().map(() => Array(config.gridSize).fill(0));
    
    // Inicializar el contenedor de zonas para el renderizado de etiquetas
    window.patchData.zonas = [];

    const gs = config.gridSize;

    // 1. PISTA DE BAILE (Zona central despejada)
    const dfSize = Math.floor(gs * 0.4);
    const dfX = Math.floor((gs - dfSize) / 2);
    const dfY = Math.floor((gs - dfSize) / 2);
    window.patchData.zonas.push({x: dfX, y: dfY, w: dfSize, h: dfSize, label: "DANCEFLOOR", type: "dancefloor"});

    // 2. BARRA DE BAR (Pared lateral izquierda)
    for(let y = 5; y < gs - 5; y++) {
        grid[5][y] = 1; // Colocaci√≥n de obst√°culos f√≠sicos
    }
    window.patchData.zonas.push({x: 2, y: 5, w: 3, h: gs-10, label: "BAR_AREA", type: "bar"});

    // 3. ZONA VIP (Fondo con separadores)
    window.patchData.zonas.push({x: gs-8, y: 5, w: 6, h: gs-10, label: "VIP_LOUNGE", type: "vip"});
    for(let y = 5; y < gs - 5; y++) {
        if(y % 4 === 0) grid[gs-5][y] = 1; // Paredes peque√±as cada 4 espacios
    }

    // 4. CABINA DEL DJ (Zona frontal/Superior)
    const djX = Math.floor(gs/2) - 3;
    window.patchData.djX = djX;
    window.patchData.djOffset = 0;
    for(let x = djX; x < djX + 6; x++) {
        grid[x][2] = 1; // Mesa del DJ
    }
    window.patchData.zonas.push({x: djX, y: 0, w: 6, h: 3, label: "DJ_BOOTH", type: "staff"});

    console.log("Structure Layout Gen: Completo [V2 Source]");
}


</script>



</body>
</html>
